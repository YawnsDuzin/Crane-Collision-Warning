# 02. 시스템 구조

이 문서는 크레인 충돌 예측 시스템의 **전체 구조**를 설명합니다.
코드를 처음 보는 분도 전체 흐름을 파악할 수 있도록 작성하였습니다.

---

## 1. 전체 시스템 아키텍처

시스템은 크게 **3개 계층**으로 구성됩니다.

```
  ┌─────────────────────────────────────────────────────────┐
  │                   [1] 데이터 수집 계층                    │
  │                                                         │
  │  시뮬레이션 모드:  simulator/engine.py 가 가상 데이터 생성  │
  │  실제 모드(향후): 센서 → 게이트웨이 → 서버로 실시간 수신     │
  └──────────────────────┬──────────────────────────────────┘
                         │  크레인 위치/속도 데이터
                         ▼
  ┌─────────────────────────────────────────────────────────┐
  │                   [2] 데이터 처리 계층                    │
  │                                                         │
  │  core/crane.py     → 크레인 객체 (위치, 각도, 속도 보관)   │
  │  core/geometry.py  → 3D 좌표 수학 계산                    │
  │  core/collision.py → 충돌 위험 판정 (거리 + 궤적 예측)     │
  │  core/alert.py     → 경고 메시지 생성 (텍스트, 음성, 색상)  │
  └──────────────────────┬──────────────────────────────────┘
                         │  판정 결과 + 경고 메시지
                         ▼
  ┌─────────────────────────────────────────────────────────┐
  │                   [3] 출력/표시 계층                      │
  │                                                         │
  │  server/app.py        → FastAPI 웹 서버                  │
  │  server/routes.py     → REST API (조회/제어)              │
  │  server/websocket.py  → WebSocket (실시간 데이터 전송)     │
  │  templates/index.html → 관제 화면 HTML                    │
  │  static/js/*.js       → 3D 시각화 + UI 제어               │
  └─────────────────────────────────────────────────────────┘
```

**핵심 원리**: 데이터가 아래 방향으로 흐릅니다.
센서(또는 시뮬레이터)가 데이터를 만들고, 처리 계층이 위험을 판단하고,
출력 계층이 사람에게 보여줍니다.

---

## 2. 프로젝트 파일 구조 및 역할

```
Crane-Collision-Warning/
│
├── config/
│   └── settings.py          ← 모든 설정값을 한 곳에서 관리
│
├── core/                    ← 핵심 로직 (이 폴더가 시스템의 두뇌)
│   ├── geometry.py          ← 3D 좌표 수학 함수
│   ├── crane.py             ← TowerCrane 클래스 (크레인 1대 표현)
│   ├── collision.py         ← CollisionEngine 클래스 (충돌 판정)
│   └── alert.py             ← AlertManager 클래스 (경고 메시지)
│
├── simulator/               ← 가상 테스트 환경
│   ├── engine.py            ← SimulationEngine (가상 크레인 구동)
│   └── scenarios.py         ← 5가지 사전 정의 시나리오
│
├── server/                  ← 웹 서버
│   ├── app.py               ← FastAPI 앱 진입점
│   ├── routes.py            ← REST API 엔드포인트
│   └── websocket.py         ← WebSocket 실시간 통신
│
├── templates/
│   └── index.html           ← 관제실 메인 화면 (HTML)
│
└── static/
    ├── css/style.css        ← 화면 스타일
    └── js/
        ├── three-scene.js   ← Three.js 3D 시각화
        ├── websocket-client.js ← WebSocket 클라이언트
        └── main.js          ← UI 제어 로직
```

### 2.1 `config/settings.py` -- 설정 파일

시스템의 **모든 설정값**을 한 곳에 모아놓은 파일입니다.
코드를 수정하지 않고 이 파일의 숫자만 바꾸면 동작이 달라집니다.

| 설정 항목 | 기본값 | 의미 |
|-----------|--------|------|
| `SERVER_PORT` | 8000 | 웹 서버 접속 포트 |
| `SIMULATION_INTERVAL_MS` | 100 | 시뮬레이션 갱신 주기 (0.1초) |
| `WEBSOCKET_BROADCAST_INTERVAL_MS` | 200 | 브라우저 전송 주기 (0.2초) |
| `ALERT_THRESHOLDS` | 3m/5m/10m | 위험/경고/주의 거리 기준 |
| `PREDICTION_TIME_SECONDS` | 30.0 | 미래 몇 초까지 예측할지 |
| `PREDICTION_STEP_SECONDS` | 0.5 | 예측 시 시간 간격 |
| `SAFETY_MARGIN_METERS` | 2.0 | 충돌 판단 안전 여유 거리 |
| `DEFAULT_CRANES` | 3대 | 시뮬레이션용 기본 크레인 |

### 2.2 `core/geometry.py` -- 3D 좌표 수학

크레인의 붐대(팔) 끝이 3D 공간의 **어디에 있는지** 계산합니다.

```
  주요 함수:

  calculate_boom_tip_position()  붐대 끝점 3D 좌표 계산
  calculate_distance_3d()        두 점 사이 거리 (3D)
  calculate_distance_2d()        두 점 사이 거리 (2D, 수평만)
  check_working_radius_overlap() 두 크레인 작업 반경 겹침 확인
  predict_future_position()      미래 시점의 붐대 위치 예측
  closest_distance_between_segments()  두 선분(붐대) 간 최소 거리
```

붐대 끝점 계산 원리 (옆에서 본 모습):

```
                     붐대 끝점 (tip)
                        *
                       /
                      /  붐대 길이 (boom_length)
                     /
                    / ← 기복각 (luffing_angle)
                   /
     마스트 꼭대기 *
                   |
                   |  마스트 높이 (mast_height)
                   |
     ─────────────*──────────── 지면
                기초 (base_x, base_y)
```

수평 거리 = `boom_length * cos(luffing_angle)`,
높이 추가분 = `boom_length * sin(luffing_angle)`,
선회각(slew_angle)으로 X/Y 방향을 결정합니다.

### 2.3 `core/crane.py` -- TowerCrane 클래스

타워크레인 1대를 Python 객체로 표현합니다.

```
  TowerCrane
  ├── 고정 속성 (설치 시 결정)
  │   ├── id           "TC-1"
  │   ├── name         "1호기"
  │   ├── base_x/y     기초 좌표 (미터)
  │   ├── mast_height  마스트 높이 (미터)
  │   └── boom_length  붐대 길이 (미터)
  │
  ├── 변동 속성 (운전 중 실시간 변경)
  │   ├── slew_angle   현재 선회각 (도)
  │   ├── luffing_angle 현재 기복각 (도)
  │   ├── slew_speed   선회 속도 (도/초)
  │   └── luffing_speed 기복 속도 (도/초)
  │
  └── 주요 메서드
      ├── get_boom_tip_position()  붐대 끝점 좌표 반환
      ├── get_working_radius()     현재 작업 반경 반환
      ├── update_position(dt)      시간 경과 후 각도 갱신
      └── to_dict()                JSON 전송용 딕셔너리 변환
```

### 2.4 `core/collision.py` -- CollisionEngine 클래스

**시스템의 두뇌**입니다. 모든 크레인 쌍의 충돌 위험을 판정합니다.

```
  판정 흐름 (크레인 쌍 하나당):

  ┌──────────────────────────────────┐
  │ 1. 작업 반경 겹침 확인 (빠른필터) │
  │    겹치지 않으면 → NORMAL (끝)    │
  └──────────────┬───────────────────┘
                 │ 겹침
                 ▼
  ┌──────────────────────────────────┐
  │ 2. 현재 거리 측정                 │
  │    - 붐대 끝점 간 거리            │
  │    - 붐대 선분 간 최소 거리       │
  └──────────────┬───────────────────┘
                 │
                 ▼
  ┌──────────────────────────────────┐
  │ 3. 미래 궤적 예측 (30초 앞까지)   │
  │    0.5초 간격으로 미래 위치 계산   │
  │    → 최소 접근 거리/시점 탐색     │
  └──────────────┬───────────────────┘
                 │
                 ▼
  ┌──────────────────────────────────┐
  │ 4. 위험 등급 판정                 │
  │    거리 기준 vs 시간 기준         │
  │    → 더 위험한 쪽 채택            │
  └──────────────────────────────────┘
```

위험 등급 기준:

```
  등급       거리 기준    시간 기준      색상     조치
  ─────────────────────────────────────────────────────
  DANGER     <= 3m       <= 5초        빨강     즉시 정지
  WARNING    <= 5m       <= 10초       주황     속도 제한
  CAUTION    <= 10m      <= 30초       노랑     운전자 알림
  NORMAL     > 10m       > 30초        초록     정상 운행
```

### 2.5 `core/alert.py` -- AlertManager 클래스

충돌 판정 결과를 **사람이 이해할 수 있는 메시지**로 바꿉니다.

- 화면 표시용 메시지: `"1호기 <-> 2호기: 거리 4.2m - 10초 후 접근 예상 (경고)"`
- 음성 안내 텍스트: `"경고. 2호기 접근 중. 10초 후 충돌 예상. 거리 4미터."`
- 색상 코드: `#FF8C00` (주황)

### 2.6 `simulator/engine.py` -- SimulationEngine

가상 크레인을 만들어 충돌 시스템을 테스트합니다.

```
  시뮬레이션 루프 (0.1초마다 반복):

  ┌─────────────────────────┐
  │ 1. 시간 경과 계산 (dt)   │
  └───────────┬─────────────┘
              ▼
  ┌─────────────────────────┐
  │ 2. 각 크레인 위치 갱신    │
  │    각도 += 속도 * dt     │
  └───────────┬─────────────┘
              ▼
  ┌─────────────────────────┐
  │ 3. 충돌 검사 수행         │
  │    (CollisionEngine)     │
  └───────────┬─────────────┘
              ▼
  ┌─────────────────────────┐
  │ 4. 경고 메시지 생성       │
  │    (AlertManager)        │
  └───────────┬─────────────┘
              ▼
  ┌─────────────────────────┐
  │ 5. WebSocket으로 전송     │
  │    (broadcast_state)     │
  └───────────┬─────────────┘
              ▼
       0.1초 대기 후 반복
```

### 2.7 `simulator/scenarios.py` -- 사전 정의 시나리오

5가지 테스트 시나리오가 미리 준비되어 있습니다.

| 시나리오 | 설명 | 크레인 수 |
|----------|------|-----------|
| `normal_operation` | 안전 거리에서 정상 운행 | 3대 |
| `approaching` | 두 크레인이 서로 접근 (등급 점진 상승) | 2대 |
| `head_on_collision` | 붐대가 서로 정면으로 겹침 (즉시 위험) | 2대 |
| `crossing_paths` | 붐대 교차 통과 (타이밍에 따라 변동) | 2대 |
| `multi_crane_congestion` | 좁은 구역에 4대 밀집 (동시 다발 경고) | 4대 |

### 2.8 `server/app.py` -- FastAPI 웹 서버

모든 것을 하나로 묶는 **진입점**입니다.

서버 시작 시 순서:
1. FastAPI 앱 생성
2. 정적 파일(`/static`) 및 템플릿(`/templates`) 경로 설정
3. REST API 라우터, WebSocket 라우터 등록
4. `SimulationEngine` 전역 인스턴스 생성
5. 기본 크레인 3대 로드
6. 시뮬레이션 비동기 루프 시작

### 2.9 `server/routes.py` -- REST API 엔드포인트

웹 브라우저(또는 외부 시스템)가 HTTP로 데이터를 조회/제어합니다.

```
  GET  /api/cranes              모든 크레인 상태 조회
  GET  /api/cranes/{id}         특정 크레인 상태 조회
  POST /api/cranes/{id}/control 크레인 속도/각도 변경
  POST /api/cranes              새 크레인 추가
  DELETE /api/cranes/{id}       크레인 제거
  GET  /api/status              전체 시스템 상태
  GET  /api/collisions          충돌 검사 결과
  GET  /api/scenarios           시나리오 목록
  POST /api/scenarios/apply     시나리오 적용
  POST /api/simulation/speed    시뮬레이션 속도 변경
```

### 2.10 `server/websocket.py` -- WebSocket 실시간 통신

서버가 0.2초마다 브라우저에 데이터를 **자동 전송**합니다.
브라우저도 제어 명령을 서버로 보낼 수 있습니다.

지원하는 메시지 타입:
- `control` -- 크레인 속도/각도 변경
- `scenario` -- 시나리오 적용
- `sim_speed` -- 시뮬레이션 속도 배율 변경
- `stop_all` -- 모든 크레인 즉시 정지

### 2.11 프론트엔드 파일들

| 파일 | 역할 |
|------|------|
| `templates/index.html` | 관제 화면 레이아웃 (3D 뷰, 상태 패널, 제어 패널) |
| `static/js/three-scene.js` | Three.js로 크레인을 3D 렌더링 (마스트, 붐대, 작업 반경 원) |
| `static/js/websocket-client.js` | WebSocket 연결/재연결/메시지 송수신 |
| `static/js/main.js` | 페이지 초기화, 데이터 수신 시 UI/3D 업데이트, 버튼/슬라이더 이벤트 |

---

## 3. 데이터 흐름 다이어그램

데이터가 센서(또는 시뮬레이터)에서 출발하여 사용자 화면까지 도달하는 전체 과정입니다.

```
  ┌──────────────┐
  │  센서 / GPS   │  (실제 모드 - 향후 구현)
  │  IMU / 인코더 │
  └──────┬───────┘
         │ 크레인 각도, 속도 데이터
         │
         │    ┌──────────────────┐
         ├───→│ simulator/       │  (시뮬레이션 모드 - 현재)
         │    │ engine.py        │  가상 데이터를 생성하여
         │    │                  │  아래 단계에 전달
         │    └────────┬─────────┘
         │             │
         ▼             ▼
  ┌────────────────────────────────────────────┐
  │  core/ 계층 (서버 내부)                      │
  │                                            │
  │  crane.py                                  │
  │  ┌─────────────┐  ┌─────────────┐          │
  │  │ TowerCrane  │  │ TowerCrane  │  ...     │
  │  │ TC-1        │  │ TC-2        │          │
  │  └──────┬──────┘  └──────┬──────┘          │
  │         └────────┬───────┘                 │
  │                  ▼                         │
  │  collision.py (CollisionEngine)            │
  │  ┌─────────────────────────────────┐       │
  │  │ 모든 크레인 쌍 거리/궤적 계산    │       │
  │  │ → 위험 등급 판정                │       │
  │  └──────────────┬──────────────────┘       │
  │                 ▼                          │
  │  alert.py (AlertManager)                   │
  │  ┌─────────────────────────────────┐       │
  │  │ 경고 메시지 + 음성 텍스트 생성   │       │
  │  └──────────────┬──────────────────┘       │
  └─────────────────┼──────────────────────────┘
                    │
                    ▼  JSON 데이터
  ┌────────────────────────────────────────────┐
  │  server/ 계층                               │
  │                                            │
  │  websocket.py ──── WebSocket ───→ 브라우저  │
  │  (0.2초마다 자동 전송)                       │
  │                                            │
  │  routes.py ──── REST API ───→ 외부 시스템   │
  │  (요청 시 응답)                              │
  └────────────────────────────────────────────┘
                    │
                    ▼
  ┌────────────────────────────────────────────┐
  │  브라우저 (관제 화면)                        │
  │                                            │
  │  websocket-client.js  ← 데이터 수신         │
  │         │                                  │
  │         ├──→ main.js  ← UI 업데이트         │
  │         │    (상태 패널, 경고 목록, 테이블)    │
  │         │                                  │
  │         └──→ three-scene.js ← 3D 업데이트   │
  │              (크레인 회전, 색상 변경)          │
  └────────────────────────────────────────────┘
```

### 전송되는 JSON 데이터 구조

서버가 WebSocket으로 보내는 데이터는 다음과 같은 형태입니다:

```
  {
    "cranes": [
      { "id": "TC-1", "slew_angle": 45.2, "boom_tip": {...}, ... },
      { "id": "TC-2", ... }
    ],
    "collisions": [
      { "crane_a_id": "TC-1", "crane_b_id": "TC-2",
        "alert_level": "WARNING", "current_distance": 4.5, ... }
    ],
    "alerts": [
      { "message": "1호기 <-> 2호기: 거리 4.5m (경고)", ... }
    ],
    "status": {
      "total_cranes": 3, "highest_alert": "WARNING", ...
    },
    "simulation": {
      "is_running": true, "tick_count": 1234, ...
    }
  }
```

---

## 4. 시뮬레이션 모드 vs 실제 모드

### 4.1 현재: 시뮬레이션 모드

실제 크레인 없이 소프트웨어만으로 시스템을 검증합니다.

```
  ┌───────────────────────────────────────────────────┐
  │               시뮬레이션 모드                       │
  │                                                   │
  │  simulator/engine.py 가 가상 크레인을 생성          │
  │  → 설정된 속도(도/초)에 따라 각도를 매 틱마다 갱신    │
  │  → 갱신된 데이터를 core/ 계층에 전달               │
  │  → core/ 계층은 "이게 진짜든 가짜든" 동일하게 동작   │
  │                                                   │
  │  [데이터 흐름]                                     │
  │  settings.py(기본 크레인 설정)                      │
  │       │                                           │
  │       ▼                                           │
  │  SimulationEngine.setup_default_cranes()           │
  │       │                                           │
  │       ▼                                           │
  │  매 0.1초마다:                                     │
  │    crane.update_position(dt)  ← 각도 += 속도 * dt │
  │    collision_engine.check_all_collisions()         │
  │    alert_manager.process_results()                 │
  │    broadcast_state()  → 브라우저로 전송             │
  └───────────────────────────────────────────────────┘
```

### 4.2 향후: 실제 모드

실제 크레인에 센서를 부착하여 진짜 데이터를 수신합니다.

```
  ┌───────────────────────────────────────────────────┐
  │               실제 모드 (향후 구현)                  │
  │                                                   │
  │  크레인에 설치된 센서 (GPS, 인코더, IMU 등)          │
  │       │                                           │
  │       ▼                                           │
  │  게이트웨이 장비 (현장 설치)                         │
  │       │  TCP/UDP 또는 MQTT                        │
  │       ▼                                           │
  │  서버의 데이터 수신 모듈 (새로 개발 필요)             │
  │       │                                           │
  │       ▼                                           │
  │  TowerCrane 객체의 속성을 직접 갱신                 │
  │    crane.slew_angle = 센서에서 받은 각도            │
  │    crane.slew_speed = 센서에서 받은 속도            │
  │       │                                           │
  │       ▼                                           │
  │  이후 과정은 시뮬레이션 모드와 100% 동일             │
  │    collision_engine.check_all_collisions()         │
  │    alert_manager.process_results()                 │
  │    broadcast_state()                              │
  └───────────────────────────────────────────────────┘
```

**핵심 설계 포인트**: `core/` 폴더의 코드는 데이터가 시뮬레이션에서 온 것인지,
실제 센서에서 온 것인지 **전혀 구분하지 않습니다**.
데이터 입력 부분만 교체하면 나머지 시스템은 그대로 사용할 수 있습니다.

---

## 5. 기술 스택 설명

### 5.1 백엔드 (서버)

| 기술 | 용도 | 왜 선택했는가 |
|------|------|---------------|
| **Python 3** | 서버 프로그래밍 언어 | 배우기 쉽고, 수학 계산 라이브러리 풍부 |
| **FastAPI** | 웹 서버 프레임워크 | 비동기 지원, 자동 API 문서, WebSocket 내장 |
| **Uvicorn** | ASGI 서버 | FastAPI 실행기, 고성능 비동기 처리 |
| **Pydantic** | 데이터 검증 | API 요청/응답 형식 자동 검증 |
| **asyncio** | 비동기 프로그래밍 | 시뮬레이션 루프와 웹 서버를 동시 실행 |
| **Jinja2** | HTML 템플릿 | 서버에서 HTML 페이지 렌더링 |
| **math** (표준) | 삼각함수 계산 | sin, cos 등 3D 좌표 계산에 사용 |
| **dataclasses** (표준) | 데이터 클래스 | TowerCrane 등 객체 정의 간소화 |

### 5.2 프론트엔드 (브라우저)

| 기술 | 용도 | 왜 선택했는가 |
|------|------|---------------|
| **HTML/CSS** | 화면 레이아웃 | 웹 표준, 별도 설치 불필요 |
| **JavaScript** | 브라우저 로직 | 웹 브라우저 내장 언어 |
| **Three.js** | 3D 시각화 | 웹에서 3D 그래픽을 가장 쉽게 구현 |
| **WebSocket API** | 실시간 통신 | 브라우저 내장, 양방향 통신 |
| **OrbitControls** | 3D 카메라 조작 | Three.js 플러그인, 마우스로 회전/줌 |

### 5.3 통신 프로토콜

```
  ┌─────────────┐          ┌─────────────┐
  │  브라우저     │          │  서버        │
  │             │          │             │
  │  REST API ──┼── HTTP ──┼──→ routes.py │  (일회성 요청/응답)
  │             │          │             │
  │  WebSocket ─┼── WS ───┼──→ websocket │  (실시간 양방향)
  │             │          │    .py      │
  └─────────────┘          └─────────────┘

  REST API: 시나리오 변경, 크레인 추가 등 가끔 하는 작업
  WebSocket: 크레인 위치, 충돌 정보 등 초당 5회 실시간 갱신
```

- **REST API (HTTP)**: 요청할 때만 응답하는 "질문-대답" 방식.
  시나리오 목록 조회, 크레인 추가/삭제 같은 비정기적 작업에 사용합니다.

- **WebSocket**: 한번 연결하면 서버가 자동으로 데이터를 보내는 "실시간" 방식.
  크레인 위치와 충돌 정보처럼 0.2초마다 갱신되는 데이터에 사용합니다.

### 5.4 좌표 체계

시스템 내부와 3D 화면에서 사용하는 좌표축이 약간 다릅니다.

```
  시스템 내부 좌표 (geometry.py)      Three.js 좌표 (three-scene.js)
  ─────────────────────────         ──────────────────────────
  X축 → 동쪽 (오른쪽)                X축 → 오른쪽
  Y축 → 북쪽 (위쪽, 평면)            Y축 → 위쪽 (높이!)
  Z축 → 하늘 (높이)                  Z축 → 앞쪽

  변환: 시스템 Z ←→ Three.js Y (서로 교환)
```

`three-scene.js`에서 서버 데이터를 3D로 그릴 때,
시스템의 Z값(높이)을 Three.js의 Y축에, 시스템의 Y값을 Z축에 매핑합니다.

---

## 요약

```
  전체 한 줄 요약:

  시뮬레이터(또는 센서)가 크레인 각도/속도를 생성
    → CollisionEngine이 모든 쌍의 충돌 위험을 판정
    → AlertManager가 경고 메시지를 생성
    → FastAPI + WebSocket이 0.2초마다 브라우저에 전송
    → Three.js가 3D로 시각화, main.js가 UI를 갱신
```

이 구조 덕분에 각 모듈을 **독립적으로** 수정하고 테스트할 수 있습니다.
예를 들어 충돌 판정 알고리즘을 개선하려면 `core/collision.py`만 수정하면 되고,
화면 디자인을 바꾸려면 `templates/`와 `static/` 파일만 수정하면 됩니다.
