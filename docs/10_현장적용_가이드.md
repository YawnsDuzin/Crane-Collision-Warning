# 현장 적용 가이드 - 크레인 충돌 예측 시스템

> **대상 독자**: 본 시스템을 시뮬레이션 단계에서 실제 건설 현장까지 배포하고자 하는 엔지니어
>
> **전제 조건**: `python run.py`로 시뮬레이션을 실행해 본 경험이 있으면 충분합니다.
>
> **문서 버전**: 1.0 (2026-02)

---

## 목차

1. [개발 단계 로드맵](#1-개발-단계-로드맵)
2. [센서 선택 가이드](#2-센서-선택-가이드)
3. [데이터 수집 아키텍처](#3-데이터-수집-아키텍처)
4. [시스템에 센서 연동하기](#4-시스템에-센서-연동하기)
5. [하드웨어 구성](#5-하드웨어-구성)
6. [경보 출력 장치](#6-경보-출력-장치)
7. [설치 체크리스트](#7-설치-체크리스트)
8. [캘리브레이션 (교정) 방법](#8-캘리브레이션-교정-방법)
9. [유지보수 가이드](#9-유지보수-가이드)
10. [안전 규정 및 인증](#10-안전-규정-및-인증)
11. [비용 추정](#11-비용-추정)

---

## 1. 개발 단계 로드맵

시뮬레이션에서 실제 현장 운영까지 **5단계**로 진행합니다.
각 단계를 건너뛰지 않고 순서대로 진행해야 안전한 배포가 가능합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        개발 단계 로드맵                          │
├─────────┬─────────┬─────────┬──────────┬────────────┤
│ Stage 1 │ Stage 2 │ Stage 3 │ Stage 4  │  Stage 5   │
│ 시뮬레이션│ 센서 연동 │ 실내 테스트│ 현장 시범  │  본격 운영   │
│  검증    │         │         │  운영     │            │
│         │         │         │          │            │
│ 2~4주   │ 4~6주   │ 2~4주   │ 4~8주    │  상시 운영   │
│ (현재)   │         │         │          │            │
└─────────┴─────────┴─────────┴──────────┴────────────┘
     ▲
     │
   현재 위치
```

### Stage 1: 시뮬레이션 검증 (현재 단계)

**목표**: 소프트웨어 로직의 정확성을 충분히 검증한다.

현재 시스템은 `simulator/engine.py`의 `SimulationEngine`이 가상 크레인 데이터를 생성하고,
`core/collision.py`의 `CollisionEngine`이 충돌 판정을 수행합니다.

이 단계에서 해야 할 일:

- [x] `python run.py`로 웹 UI 확인
- [x] 5가지 시나리오(`simulator/scenarios.py`) 모두 테스트
- [x] `tests/` 디렉토리의 단위 테스트 통과 확인 (`pytest`)
- [ ] `config/settings.py`의 `ALERT_THRESHOLDS` 기준값 검토
- [ ] 현장 크레인 사양에 맞게 `DEFAULT_CRANES` 수정 후 시뮬레이션
- [ ] 다양한 시나리오에서 경고 등급 전환이 올바른지 확인

**판정 기준**: 시뮬레이션에서 오탐(false positive)과 미탐(false negative)이 모두 0건일 때 다음 단계로 진행합니다.

### Stage 2: 센서 연동

**목표**: 실제 센서에서 데이터를 읽어 시스템에 입력할 수 있도록 한다.

이 단계에서 해야 할 일:

- [ ] 센서 선정 및 구매 (아래 [센서 선택 가이드](#2-센서-선택-가이드) 참조)
- [ ] 센서 드라이버 개발 또는 라이브러리 설치
- [ ] `sensor_reader.py` 모듈 개발 (아래 [센서 연동](#4-시스템에-센서-연동하기) 참조)
- [ ] 센서 단독 데이터 수집 테스트 (노이즈, 샘플링 레이트 확인)
- [ ] 시뮬레이션 데이터와 센서 데이터를 비교하여 일관성 검증

**판정 기준**: 센서에서 10Hz 이상으로 안정적인 데이터를 읽을 수 있을 때 다음 단계로 진행합니다.

### Stage 3: 실내 테스트

**목표**: 축소 모형이나 실험 장비로 전체 시스템을 통합 테스트한다.

이 단계에서 해야 할 일:

- [ ] 축소 모형 크레인 또는 회전 테스트 지그 제작
- [ ] 센서를 모형에 설치하고 데이터 수집
- [ ] 모형에서 충돌 시나리오를 재현하여 경고 발생 확인
- [ ] 경보 장치(LED, 부저) 연동 테스트
- [ ] WebSocket 실시간 데이터 전송 지연 시간 측정 (목표: 200ms 이내)
- [ ] 24시간 연속 운전 안정성 테스트

**판정 기준**: 축소 모형에서 모든 경고 시나리오가 정확히 동작할 때 다음 단계로 진행합니다.

### Stage 4: 현장 시범 운영

**목표**: 실제 건설 현장에서 **경고만 출력**하는 모드로 운영하며 신뢰성을 검증한다.

이 단계에서 해야 할 일:

- [ ] 현장 사전 조사 (크레인 위치, 네트워크 환경, 전원)
- [ ] 센서 설치 및 케이블 배선
- [ ] 현장 좌표계 설정 및 캘리브레이션
- [ ] **경고 전용 모드**로 운영 (자동 정지 연동 없이 모니터링만)
- [ ] 운전자 피드백 수집
- [ ] 최소 2주 이상 연속 운영하며 오탐/미탐 기록
- [ ] 오탐/미탐 원인 분석 및 파라미터 조정

**판정 기준**: 2주간 오탐율 5% 이하, 미탐 0건일 때 다음 단계로 진행합니다.

### Stage 5: 본격 운영

**목표**: 전체 기능을 활성화하고 상시 운영 체제로 전환한다.

이 단계에서 해야 할 일:

- [ ] 경보 임계값 최종 확정
- [ ] 자동 정지 연동 검토 (선택사항)
- [ ] 운전자 교육 실시
- [ ] 유지보수 스케줄 확정
- [ ] 비상 절차 매뉴얼 작성
- [ ] 정기 보고서 양식 확정

---

## 2. 센서 선택 가이드

타워크레인의 움직임을 실시간으로 파악하려면 다음 센서들이 필요합니다.
아래 그림은 각 센서가 크레인의 어느 부위에 설치되는지를 보여줍니다.

```
                  센서 설치 위치도
                  ===============

                         풍속계 [D]
                           │
                           ▼
               ┌──────────────────────┐
               │     운전실 상부       │
               └──────────┬───────────┘
                          │
             붐대 끝점     │    기복각 센서 [B]
                ●─────────┤◄── (인클리노미터)
               ╱          │
              ╱           │
             ╱ 붐대       │
            ╱             │
           ╱              │  ◄── 선회각 센서 [A]
          ●───────────────┤      (로터리 엔코더)
        마스트 꼭대기      │      (선회 베어링부에 설치)
                          │
                          │  마스트
                          │
                          │
                          │
                ──────────●──────────  지면
                    기초 위치
                   GPS/RTK [C]
                  (기초부 또는 인근 측량점)
```

### [A] 선회각 센서 - 로터리 엔코더 (Rotary Encoder)

| 항목 | 내용 |
|------|------|
| **측정값** | 선회각 (slew_angle) - 크레인 상부가 회전한 각도 |
| **코드 매핑** | `TowerCrane.slew_angle` (단위: 도, 0=북, 시계방향 양수) |
| **센서 종류** | 절대형(Absolute) 로터리 엔코더 권장 |
| **분해능** | 최소 12비트 (4096 분할 = 0.088도/펄스), 16비트 권장 |
| **출력 방식** | SSI, BiSS-C, 또는 아날로그 4-20mA |
| **설치 위치** | 선회 베어링부 (마스트와 상부 회전체의 연결부) |
| **가격 범위** | 30만~150만원 (산업용 절대형 기준) |
| **주요 제조사** | Heidenhain, Sick, Kubler, Autonics |
| **연결 방법** | SSI/BiSS → RS-485 컨버터 → 엣지 컴퓨터, 또는 PLC 입력 모듈 |

**왜 절대형인가?**
증분형(Incremental) 엔코더는 전원이 꺼지면 위치를 잃어버립니다.
절대형은 전원 재투입 후에도 현재 각도를 즉시 알 수 있어 건설 현장에 적합합니다.

**설치 시 주의사항:**
- 선회 베어링의 기어비를 고려하여 최종 각도를 계산해야 합니다.
- 커플링(연결부)의 백래시(유격)가 측정 오차를 유발하므로, 백래시가 적은 커플링을 사용합니다.
- 방수/방진 등급 IP65 이상의 제품을 선택합니다.

### [B] 기복각 센서 - 경사계/인클리노미터 (Inclinometer)

| 항목 | 내용 |
|------|------|
| **측정값** | 기복각 (luffing_angle) - 붐대의 수직 경사 각도 |
| **코드 매핑** | `TowerCrane.luffing_angle` (단위: 도, 0=수평, 위로 양수) |
| **센서 종류** | MEMS 경사계 (1축 또는 2축) |
| **측정 범위** | 0~90도 (실사용 범위: 0~80도) |
| **분해능** | 0.01도 이상 |
| **정확도** | +/- 0.1도 이내 |
| **출력 방식** | 아날로그 4-20mA, 0-10V, 또는 RS-485 (Modbus RTU) |
| **설치 위치** | 붐대 기저부 (마스트와 붐대의 연결 힌지 근처) |
| **가격 범위** | 20만~80만원 |
| **주요 제조사** | Posital/Fraba, Moog, Turck, Jewell Instruments |
| **연결 방법** | 아날로그 → PLC AI 모듈, 또는 Modbus RTU → RS-485 → 엣지 컴퓨터 |

**설치 시 주의사항:**
- 붐대의 진동이 심하므로, 소프트웨어 필터링(이동평균, 칼만필터)이 필수입니다.
- 온도 보상 기능이 있는 제품을 선택합니다 (여름/겨울 온도차가 큼).
- 설치 방향(수평 기준면)을 캘리브레이션에서 반드시 보정합니다.

### [C] GPS/RTK - 기초 위치 확인용

| 항목 | 내용 |
|------|------|
| **측정값** | 크레인 기초의 절대 좌표 (위도, 경도, 고도) |
| **코드 매핑** | `TowerCrane.base_x`, `TowerCrane.base_y` (현장 좌표계로 변환 후) |
| **센서 종류** | RTK-GNSS 수신기 (cm 급 정밀도) |
| **정확도** | 수평 +/- 2cm (RTK Fix 상태) |
| **출력 방식** | NMEA 0183 (시리얼), 또는 RTCM 보정 데이터 |
| **설치 시점** | 초기 설치 시 1회 측량 (상시 설치할 필요 없음) |
| **가격 범위** | 200만~500만원 (측량 서비스 이용 시 50만~100만원/회) |
| **주요 제조사** | Trimble, Leica, Topcon, u-blox (저가형) |
| **연결 방법** | 시리얼(RS-232) 또는 USB → 엣지 컴퓨터 |

**왜 필요한가?**
`config/settings.py`의 `DEFAULT_CRANES`에서 `base_x`, `base_y` 값을 정확하게 설정하려면,
크레인 기초 위치를 정밀하게 측량해야 합니다.

**비용 절감 팁:**
- RTK 장비를 상시 설치할 필요는 없습니다.
- 크레인 설치 시 측량사가 기초 좌표를 1회 측량하면 충분합니다.
- 현장에 이미 측량 기준점이 있다면, 토탈스테이션으로도 충분합니다.

### [D] 풍속계 (Wind Sensor)

| 항목 | 내용 |
|------|------|
| **측정값** | 풍속(m/s), 풍향(도) |
| **용도** | 안전 계수 보정 - 강풍 시 경고 임계값을 엄격하게 조정 |
| **센서 종류** | 초음파 풍속계 (기계식보다 내구성 우수) |
| **측정 범위** | 0~60 m/s |
| **출력 방식** | RS-485 (Modbus RTU), 4-20mA, 또는 SDI-12 |
| **설치 위치** | 크레인 최상부 (운전실 위) 또는 현장 내 독립 기상 관측 폴 |
| **가격 범위** | 30만~150만원 |
| **주요 제조사** | Gill Instruments, Lufft, Young, 국산(한서) |
| **연결 방법** | RS-485 → 엣지 컴퓨터 |

**활용 방법:**
현재 코드에는 풍속 보정이 포함되어 있지 않지만, 다음과 같이 확장할 수 있습니다:
- 풍속 10m/s 이상: `ALERT_THRESHOLDS` 거리 기준을 1.5배로 강화
- 풍속 15m/s 이상: 작업 중지 권고 경보 발생
- 풍속 20m/s 이상: 강제 작업 중지 경보

### 센서별 요약 비교표

| 센서 | 필수 여부 | 가격대 | 출력 방식 | 샘플링 요구 |
|------|-----------|--------|-----------|------------|
| 선회각 엔코더 | **필수** | 30~150만원 | SSI/RS-485 | 10Hz 이상 |
| 기복각 경사계 | **필수** | 20~80만원 | Modbus/4-20mA | 10Hz 이상 |
| GPS/RTK | 설치 시 1회 | 측량비 50~100만원 | NMEA (시리얼) | 1회 |
| 풍속계 | 권장 | 30~150만원 | RS-485 | 1Hz |

---

## 3. 데이터 수집 아키텍처

### 전체 데이터 흐름도

```
┌──────────────────────────────────────────────────────────────────────┐
│                         크레인 1대 (TC-1)                            │
│                                                                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │ 선회각    │  │ 기복각    │  │ 풍속계    │  │ 기타센서  │           │
│  │ 엔코더   │  │ 경사계   │  │          │  │          │           │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘           │
│       │              │              │              │                │
│       │  RS-485 / 아날로그 / CAN Bus                │                │
│       └──────┬───────┴──────────────┴──────┬───────┘                │
│              │                              │                       │
│              ▼                              ▼                       │
│     ┌──────────────┐              ┌──────────────┐                  │
│     │  PLC / MCU   │              │  PLC / MCU   │                  │
│     │ (데이터 수집) │    또는       │ (직접 연결)  │                  │
│     └──────┬───────┘              └──────┬───────┘                  │
│            │                              │                         │
│            │  Modbus TCP / MQTT           │  USB / 시리얼            │
│            └──────────┬───────────────────┘                         │
│                       │                                             │
│                       ▼                                             │
│              ┌──────────────────┐                                   │
│              │  엣지 컴퓨터      │                                   │
│              │  (Raspberry Pi   │                                   │
│              │   또는 산업용PC)  │                                   │
│              │                  │                                   │
│              │  sensor_reader.py │  ◄── 센서 데이터 수집             │
│              │  CollisionEngine │  ◄── 충돌 판정 (core/collision.py) │
│              │  FastAPI 서버     │  ◄── 웹 UI 제공 (server/app.py)  │
│              └────────┬─────────┘                                   │
│                       │                                             │
└───────────────────────┼─────────────────────────────────────────────┘
                        │
                        │  WiFi / 이더넷 / LTE
                        │
                        ▼
               ┌──────────────────┐
               │   관제실 서버     │
               │                  │
               │  - 웹 대시보드   │  ◄── 브라우저에서 http://서버IP:8000 접속
               │  - 데이터 로깅   │
               │  - 이력 관리     │
               └──────────────────┘
```

### 통신 프로토콜 선택 가이드

| 프로토콜 | 용도 | 장점 | 단점 | 적용 구간 |
|----------|------|------|------|-----------|
| **RS-485 (Modbus RTU)** | 센서 → PLC/엣지 | 산업 표준, 장거리(1200m), 노이즈 강함 | 배선 필요 | 센서~엣지 컴퓨터 |
| **CAN Bus** | 센서 → PLC | 다중 장치 연결 우수, 실시간성 | 전용 인터페이스 필요 | 센서~PLC |
| **Modbus TCP** | PLC → 엣지 | 이더넷 기반, 설정 쉬움 | 네트워크 의존 | PLC~엣지 컴퓨터 |
| **MQTT** | 엣지 → 서버 | 가벼움, 브로커 기반, IoT 표준 | 브로커 서버 필요 | 엣지~관제실 |
| **WebSocket** | 서버 → 브라우저 | 실시간, 양방향 (이미 구현됨) | 웹 전용 | 서버~화면 표시 |

**권장 구성 (가장 간단한 경우):**
```
센서 ──RS-485──> 엣지 컴퓨터(Raspberry Pi) ──WiFi/이더넷──> 관제실 브라우저
```

### 데이터 형식 - 센서 값과 시스템 변수의 매핑

센서에서 읽어온 원시 데이터를 시스템의 `TowerCrane` 객체가 이해하는 값으로 변환해야 합니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                     데이터 매핑 예시                              │
├─────────────────────┬───────────────────┬───────────────────────┤
│ 센서 원시값          │ 변환              │ 시스템 변수             │
├─────────────────────┼───────────────────┼───────────────────────┤
│ 엔코더 카운트: 2048  │ 2048/4096 * 360  │ slew_angle = 180.0도   │
│ 경사계 전류: 12.0mA  │ (12-4)/16 * 80   │ luffing_angle = 40.0도 │
│ 엔코더 속도: +5 cnt/s│ 5/4096 * 360     │ slew_speed = 0.44도/초 │
│ GPS 위경도           │ 좌표 변환(TM)     │ base_x, base_y (미터)  │
│ 풍속계: 8.5          │ 그대로 사용        │ wind_speed = 8.5 m/s  │
└─────────────────────┴───────────────────┴───────────────────────┘
```

### 샘플 레이트 요구사항

| 데이터 | 최소 샘플 레이트 | 권장 샘플 레이트 | 이유 |
|--------|-----------------|-----------------|------|
| 선회각 | 10 Hz | 20 Hz | 충돌 예측의 핵심 입력, 속도 계산에 필요 |
| 기복각 | 10 Hz | 20 Hz | 작업 반경 변화 감지 |
| 선회 속도 | 10 Hz | 20 Hz | 엔코더 차분으로 계산 가능 |
| 풍속 | 1 Hz | 2 Hz | 느리게 변하는 값 |
| GPS | - | - | 설치 시 1회 측량 |

**참고**: 현재 시뮬레이션은 `config/settings.py`에서 `SIMULATION_INTERVAL_MS = 100` (10Hz)으로
설정되어 있습니다. 실제 센서 연동 시에도 이 주기 이상을 유지해야 합니다.

---

## 4. 시스템에 센서 연동하기

### 핵심 원리

이 시스템의 가장 큰 장점은 **충돌 판정 엔진(`core/collision.py`)이 데이터 소스에 독립적**이라는 점입니다.

```
┌─────────────────────────────────────────────────────────────┐
│                현재 구조 (시뮬레이션)                          │
│                                                             │
│  simulator/engine.py ──가상 데이터──> core/collision.py     │
│  (SimulationEngine)                  (CollisionEngine)      │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                목표 구조 (실제 센서)                           │
│                                                             │
│  sensor/reader.py ──실제 데이터──> core/collision.py        │
│  (SensorReader)                   (CollisionEngine)         │
│                                                             │
│  * core/ 디렉토리의 코드는 수정할 필요가 없습니다!             │
└─────────────────────────────────────────────────────────────┘
```

### 수정이 필요한 파일과 수정하지 않는 파일

| 파일 | 수정 여부 | 설명 |
|------|-----------|------|
| `core/collision.py` | **수정 불필요** | 충돌 판정 로직은 동일하게 동작 |
| `core/crane.py` | **수정 불필요** | TowerCrane 클래스는 그대로 사용 |
| `core/geometry.py` | **수정 불필요** | 좌표 계산 함수는 그대로 사용 |
| `core/alert.py` | **수정 불필요** | 경보 메시지 생성은 그대로 사용 |
| `config/settings.py` | **수정 필요** | 현장 크레인 사양으로 변경 |
| `simulator/engine.py` | **대체 필요** | sensor/reader.py로 대체 |
| `server/app.py` | **수정 필요** | SimulationEngine 대신 SensorEngine 사용 |

### sensor_reader.py 모듈 패턴

새로 만들어야 할 `sensor/reader.py`의 구조를 보여줍니다.
이 파일은 `simulator/engine.py`의 `SimulationEngine`과 같은 역할을 하되,
가상 데이터 대신 실제 센서에서 데이터를 읽어옵니다.

```python
"""
센서 데이터 리더 - sensor/reader.py
====================================
simulator/engine.py의 SimulationEngine을 대체하는 모듈입니다.
실제 센서에서 데이터를 읽어 CollisionEngine에 전달합니다.
"""

import asyncio
import time
from typing import Dict, Any, Optional, Callable

# --- 센서 통신 라이브러리 (설치 필요) ---
# pip install pymodbus      # Modbus RTU/TCP 통신용
# pip install pyserial      # 시리얼 통신용
# from pymodbus.client import ModbusSerialClient  # RS-485
# from pymodbus.client import ModbusTcpClient      # Modbus TCP

from core.crane import TowerCrane
from core.collision import CollisionEngine
from core.alert import AlertManager, AlertMessage
from config.settings import DEFAULT_CRANES


class SensorReader:
    """
    실제 센서에서 데이터를 읽는 클래스.

    각 센서 유형별로 읽기 메서드를 구현합니다.
    현장의 센서 구성에 맞게 이 클래스를 수정하세요.
    """

    def __init__(self, port: str = "/dev/ttyUSB0", baudrate: int = 9600):
        """
        Args:
            port: 시리얼 포트 (예: "/dev/ttyUSB0", "COM3")
            baudrate: 통신 속도 (9600, 19200, 38400, 115200)
        """
        self.port = port
        self.baudrate = baudrate
        self.client = None  # Modbus 클라이언트 (초기화 시 연결)

    def connect(self) -> bool:
        """센서와 통신 연결을 수립합니다."""
        # === 실제 구현 예시 (Modbus RTU) ===
        # from pymodbus.client import ModbusSerialClient
        # self.client = ModbusSerialClient(
        #     port=self.port,
        #     baudrate=self.baudrate,
        #     parity='N',
        #     stopbits=1,
        #     bytesize=8,
        #     timeout=1,
        # )
        # return self.client.connect()
        pass

    def disconnect(self):
        """센서 통신 연결을 해제합니다."""
        # if self.client:
        #     self.client.close()
        pass

    def read_slew_angle(self, unit_id: int = 1) -> float:
        """
        선회각 센서(로터리 엔코더)에서 현재 각도를 읽습니다.

        Args:
            unit_id: Modbus 슬레이브 ID

        Returns:
            선회각 (도, 0~360)
        """
        # === 실제 구현 예시 ===
        # result = self.client.read_holding_registers(
        #     address=0,      # 레지스터 주소 (센서 매뉴얼 참조)
        #     count=2,        # 32비트 값 = 레지스터 2개
        #     slave=unit_id,
        # )
        # if result.isError():
        #     raise IOError(f"선회각 읽기 실패: {result}")
        #
        # # 원시값을 각도로 변환
        # raw_value = (result.registers[0] << 16) | result.registers[1]
        # angle = (raw_value / 65536.0) * 360.0  # 16비트 엔코더 기준
        # return angle
        pass

    def read_luffing_angle(self, unit_id: int = 2) -> float:
        """
        기복각 센서(인클리노미터)에서 현재 경사각을 읽습니다.

        Args:
            unit_id: Modbus 슬레이브 ID

        Returns:
            기복각 (도, 0~80)
        """
        # === 실제 구현 예시 (4-20mA 아날로그 입력) ===
        # result = self.client.read_input_registers(
        #     address=0,
        #     count=1,
        #     slave=unit_id,
        # )
        # if result.isError():
        #     raise IOError(f"기복각 읽기 실패: {result}")
        #
        # # 4-20mA를 0-80도로 변환
        # raw_value = result.registers[0]
        # current_mA = 4.0 + (raw_value / 65535.0) * 16.0
        # angle = ((current_mA - 4.0) / 16.0) * 80.0
        # return max(0.0, min(80.0, angle))
        pass

    def read_wind_speed(self, unit_id: int = 3) -> float:
        """
        풍속계에서 현재 풍속을 읽습니다.

        Returns:
            풍속 (m/s)
        """
        # === 실제 구현은 센서 매뉴얼에 따라 작성 ===
        pass


class SensorEngine:
    """
    센서 기반 엔진 - SimulationEngine을 대체합니다.

    SimulationEngine과 동일한 인터페이스를 유지하므로,
    server/app.py에서 교체만 하면 됩니다.
    """

    def __init__(self, sensor_config: Dict[str, Any] = None):
        # 충돌 예측 엔진 (core/collision.py - 동일하게 사용)
        self.collision_engine = CollisionEngine()

        # 경보 관리자 (core/alert.py - 동일하게 사용)
        self.alert_manager = AlertManager()

        # 센서 리더 (크레인별로 하나씩)
        self.sensor_readers: Dict[str, SensorReader] = {}

        # 상태
        self.is_running = False
        self.tick_count = 0

        # 콜백
        self._on_update_callback: Optional[Callable] = None

        # 이전 각도값 (속도 계산용)
        self._prev_slew_angles: Dict[str, float] = {}
        self._prev_luffing_angles: Dict[str, float] = {}
        self._prev_time: float = 0.0

    def setup_cranes(self) -> None:
        """
        config/settings.py의 크레인 설정을 로드하고
        각 크레인에 대한 센서 리더를 초기화합니다.
        """
        for crane_config in DEFAULT_CRANES:
            crane = TowerCrane.from_config(crane_config)
            self.collision_engine.register_crane(crane)

            # 센서 리더 초기화 (크레인별 시리얼 포트 설정 필요)
            # 예: TC-1 → /dev/ttyUSB0, TC-2 → /dev/ttyUSB1
            # reader = SensorReader(port=crane_config.get("sensor_port", "/dev/ttyUSB0"))
            # reader.connect()
            # self.sensor_readers[crane.id] = reader

        # 경보 관리자에 이름 등록
        names = {c.id: c.name for c in self.collision_engine.cranes.values()}
        self.alert_manager.set_crane_names(names)

    def set_on_update(self, callback: Callable) -> None:
        """데이터 갱신 콜백 등록 (WebSocket 브로드캐스트용)"""
        self._on_update_callback = callback

    async def start(self) -> None:
        """
        센서 데이터 수집 루프를 시작합니다.
        SimulationEngine.start()와 동일한 구조입니다.
        """
        self.is_running = True
        self._prev_time = time.time()
        interval = 0.1  # 10Hz (100ms 주기)

        while self.is_running:
            current_time = time.time()
            dt = current_time - self._prev_time
            self._prev_time = current_time

            # 1. 각 크레인의 센서 데이터 읽기
            for crane_id, crane in self.collision_engine.cranes.items():
                reader = self.sensor_readers.get(crane_id)
                if reader is None:
                    continue

                try:
                    # 센서에서 현재 각도 읽기
                    new_slew = reader.read_slew_angle()
                    new_luffing = reader.read_luffing_angle()

                    # 속도 계산 (각도 변화량 / 시간)
                    if crane_id in self._prev_slew_angles and dt > 0:
                        crane.slew_speed = (
                            (new_slew - self._prev_slew_angles[crane_id]) / dt
                        )
                        crane.luffing_speed = (
                            (new_luffing - self._prev_luffing_angles[crane_id]) / dt
                        )

                    # 현재 각도 업데이트
                    crane.slew_angle = new_slew
                    crane.luffing_angle = new_luffing

                    # 이전값 저장
                    self._prev_slew_angles[crane_id] = new_slew
                    self._prev_luffing_angles[crane_id] = new_luffing
                    crane.last_update = current_time

                except Exception as e:
                    # 센서 읽기 실패 시 로그 기록
                    print(f"[센서 오류] {crane_id}: {e}")

            # 2. 충돌 검사 (core/collision.py 사용 - 수정 없이 동일)
            collision_results = self.collision_engine.check_all_collisions()

            # 3. 경고 생성 (core/alert.py 사용 - 수정 없이 동일)
            alerts = self.alert_manager.process_results(collision_results)

            # 4. 콜백 호출 (WebSocket으로 브라우저에 전송)
            if self._on_update_callback:
                state = self.get_full_state(collision_results, alerts)
                try:
                    await self._on_update_callback(state)
                except Exception:
                    pass

            self.tick_count += 1
            await asyncio.sleep(interval)

    def stop(self) -> None:
        """데이터 수집을 정지합니다."""
        self.is_running = False
        for reader in self.sensor_readers.values():
            reader.disconnect()

    def get_full_state(self, collision_results=None, alerts=None):
        """시스템 전체 상태를 반환합니다 (SimulationEngine과 동일 형식)."""
        if collision_results is None:
            collision_results = self.collision_engine.check_all_collisions()
        if alerts is None:
            alerts = self.alert_manager.process_results(collision_results)

        return {
            "cranes": [
                crane.to_dict()
                for crane in self.collision_engine.cranes.values()
            ],
            "collisions": [r.to_dict() for r in collision_results],
            "alerts": [a.to_dict() for a in alerts],
            "status": self.collision_engine.get_overall_status(),
            "simulation": {
                "is_running": self.is_running,
                "tick_count": self.tick_count,
                "speed_multiplier": 1.0,  # 실제 센서이므로 항상 1.0
                "active_scenario": None,
            },
        }
```

### server/app.py 수정 방법

시뮬레이션 모드에서 센서 모드로 전환하려면, `server/app.py`에서 엔진만 교체합니다:

```python
# 변경 전 (시뮬레이션 모드):
from simulator.engine import SimulationEngine
simulation_engine = SimulationEngine()

# 변경 후 (센서 모드):
from sensor.reader import SensorEngine
simulation_engine = SensorEngine()
```

그리고 `startup_event()`에서:

```python
# 변경 전:
simulation_engine.setup_default_cranes()

# 변경 후:
simulation_engine.setup_cranes()
```

**나머지 코드(`core/`, `server/routes.py`, `server/websocket.py`, 웹 UI)는 수정 불필요**입니다.
`CollisionEngine`, `AlertManager`, WebSocket 브로드캐스트 모두 동일하게 동작합니다.

---

## 5. 하드웨어 구성

### 전체 하드웨어 네트워크 구성도

```
                          현장 네트워크 구성도
   ================================================================

   크레인 TC-1                         크레인 TC-2
   ┌─────────────────────┐            ┌─────────────────────┐
   │  [운전실 디스플레이]  │            │  [운전실 디스플레이]  │
   │   7인치 터치 패널    │            │   7인치 터치 패널    │
   │                     │            │                     │
   │  [LED 신호등]        │            │  [LED 신호등]        │
   │   적/황/녹           │            │   적/황/녹           │
   │                     │            │                     │
   │  [부저/스피커]       │            │  [부저/스피커]       │
   │                     │            │                     │
   │  [엣지 컴퓨터]       │            │  [엣지 컴퓨터]       │
   │   Raspberry Pi 4    │            │   Raspberry Pi 4    │
   │   + RS-485 HAT      │            │   + RS-485 HAT      │
   │   + UPS HAT         │            │   + UPS HAT         │
   │                     │            │                     │
   │  [센서]              │            │  [센서]              │
   │   - 선회각 엔코더    │            │   - 선회각 엔코더    │
   │   - 기복각 경사계    │            │   - 기복각 경사계    │
   │   - 풍속계(공유)     │            │   - 풍속계(공유)     │
   └────────┬────────────┘            └────────┬────────────┘
            │                                   │
            │  WiFi AP 또는                      │
            │  이더넷 케이블                      │
            └───────────────┬───────────────────┘
                            │
                            ▼
                   ┌──────────────────┐
                   │  현장 네트워크     │
                   │  (WiFi AP 또는    │
                   │   산업용 스위치)   │
                   └────────┬─────────┘
                            │
                            ▼
                   ┌──────────────────┐
                   │  관제실 서버 PC    │
                   │                  │
                   │  - 중앙 서버 SW  │
                   │  - 대형 모니터   │
                   │  - 데이터 백업   │
                   │  - UPS           │
                   └──────────────────┘
```

### 엣지 컴퓨터 사양

크레인 1대당 엣지 컴퓨터 1대를 설치합니다.

**옵션 A: Raspberry Pi 4 (저비용)**

| 항목 | 사양 |
|------|------|
| 모델 | Raspberry Pi 4 Model B |
| RAM | 4GB 이상 |
| 저장장치 | 32GB 이상 SD 카드 (산업용 MLC/SLC 권장) |
| OS | Raspberry Pi OS (64-bit) 또는 Ubuntu Server 22.04 |
| 추가 HAT | RS-485 HAT (Waveshare, Sequent Microsystems 등) |
| 전원 | 5V 3A (USB-C), UPS HAT 추가 권장 |
| 네트워크 | 내장 WiFi 또는 이더넷 |
| 가격 | 약 10만~15만원 (HAT 포함) |

**옵션 B: 산업용 PC (고신뢰도)**

| 항목 | 사양 |
|------|------|
| 제조사 | Advantech, Siemens, Beckhoff, 연화엔시스 |
| CPU | Intel Celeron 이상 |
| RAM | 4GB 이상 |
| 저장장치 | 64GB 이상 SSD |
| OS | Ubuntu Server 22.04 또는 Windows IoT |
| I/O | RS-485 2포트 이상 내장 |
| 전원 | DC 12~24V (산업용 전원) |
| 내구성 | -20~60도, IP40 이상 |
| 가격 | 약 50만~150만원 |

**선택 기준:**
- 초기 테스트/소규모 현장: Raspberry Pi 4 (비용 대비 충분한 성능)
- 대규모 현장/장기 운영: 산업용 PC (내구성, 안정성 우선)

### 네트워크 구성

| 구성 요소 | 옵션 A (간단) | 옵션 B (안정) |
|-----------|--------------|--------------|
| 크레인~관제실 | WiFi (2.4GHz/5GHz) | 산업용 WiFi AP (IP67) |
| 대역폭 | 1Mbps 이상 | 10Mbps 이상 |
| 지연시간 | 50ms 이내 | 20ms 이내 |
| 백업 | - | LTE 모뎀 (failover) |
| 장비 | 일반 WiFi 공유기 | Cisco/Moxa 산업용 AP |

**주의사항:**
- 건설 현장은 금속 구조물이 많아 WiFi 전파 차단이 발생합니다.
- 크레인 운전실과 관제실 사이에 직통(Line of Sight)이 확보되어야 합니다.
- 신호가 약한 경우 외부 안테나(방향성/무지향성)를 추가 설치합니다.

### 전원 공급

| 구성 요소 | 전원 사양 | 비고 |
|-----------|-----------|------|
| 엣지 컴퓨터 (RPi4) | DC 5V 3A | USB-C |
| 엣지 컴퓨터 (산업용) | DC 12~24V | DIN 커넥터 |
| 센서류 | DC 12~24V | 센서별 상이 |
| LED 신호등 | DC 24V | 릴레이 출력 |
| 부저 | DC 12~24V | 릴레이 출력 |
| 전체 소비 전력 | 약 50~100W/크레인 | 여유분 포함 |

**UPS(무정전 전원) 필수:**
- 크레인의 전원 불안정, 순간 정전에 대비하여 UPS를 설치합니다.
- Raspberry Pi: UPS HAT (리튬이온 배터리, 30분~1시간 백업)
- 산업용 PC: DC UPS 모듈 (슈퍼캡 또는 배터리, 10분 이상 백업)

### 방수/방진 처리

건설 현장은 먼지, 비, 진동이 심한 가혹 환경입니다.

| 부품 | 권장 IP 등급 | 설치 방법 |
|------|-------------|-----------|
| 엣지 컴퓨터 | IP65 함체 내 설치 | 산업용 방수 함체(BOX)에 넣기 |
| 센서 (엔코더) | IP65 이상 | 센서 자체가 방수 등급 제품 |
| 센서 (경사계) | IP67 이상 | 센서 자체가 방수 등급 제품 |
| 케이블 | 방수 커넥터 사용 | M12 또는 방수 글랜드 |
| 커넥터 | IP67 이상 | M12, M8 산업용 커넥터 |
| 디스플레이 | IP65 이상 | 운전실 내부는 IP54 가능 |

### 운전실 디스플레이

| 항목 | 사양 |
|------|------|
| 크기 | 7~10인치 |
| 해상도 | 1024x600 이상 |
| 밝기 | 500cd/m2 이상 (주간 가시성) |
| 입력 | HDMI + 터치 (USB) |
| 동작 온도 | -20~60도 |
| 마운트 | VESA 또는 전용 브래킷 |
| 가격 | 15만~40만원 |

디스플레이는 Raspberry Pi의 HDMI 출력에 연결하고,
내장 브라우저(Chromium)에서 `http://localhost:8000`을 전체 화면으로 표시합니다.

---

## 6. 경보 출력 장치

### 경보 장치 구성도

```
                     경보 출력 장치 구성도
    =========================================================

    CollisionEngine ──> AlertManager ──> 경보 출력
       (판정)            (메시지 생성)      │
                                           │
                    ┌──────────────────────┤
                    │                      │
                    ▼                      ▼
           ┌───────────────┐    ┌───────────────────┐
           │  운전실 장치   │    │    관제실 장치      │
           │               │    │                   │
           │  ┌─────────┐  │    │  ┌─────────────┐  │
           │  │LED 신호등│  │    │  │ 웹 대시보드  │  │
           │  │ ● 적색  │  │    │  │ (이미 구현)  │  │
           │  │ ● 황색  │  │    │  └─────────────┘  │
           │  │ ● 녹색  │  │    │                   │
           │  └─────────┘  │    │  ┌─────────────┐  │
           │               │    │  │ 대형 모니터  │  │
           │  ┌─────────┐  │    │  │ (웹UI 전체화면)│  │
           │  │ 부저    │  │    │  └─────────────┘  │
           │  │ /스피커  │  │    │                   │
           │  └─────────┘  │    │  ┌─────────────┐  │
           │               │    │  │ 관제 알림음  │  │
           │  ┌─────────┐  │    │  └─────────────┘  │
           │  │ 터치패널│  │    │                   │
           │  │ 디스플레이│  │    └───────────────────┘
           │  └─────────┘  │
           │               │
           └───────────────┘
```

### [1] LED 신호등 (Traffic Light Style Indicator)

경보 등급에 따라 적/황/녹 LED를 점등합니다.

| 등급 | LED 상태 | 의미 |
|------|----------|------|
| NORMAL (정상) | 녹색 점등 | 안전한 상태 |
| CAUTION (주의) | 황색 점등 | 주의 필요 |
| WARNING (경고) | 황색 점멸 (0.5초 간격) | 속도 제한 필요 |
| DANGER (위험) | 적색 점멸 (0.25초 간격) | 즉시 정지 |

**연결 방법:**
- GPIO (Raspberry Pi) → 릴레이 모듈 → 24V LED 신호등
- 산업용: PLC 디지털 출력 → 적/황/녹 LED 타워램프

**구현 예시 (GPIO 제어):**
```python
# LED 제어 예시 (Raspberry Pi GPIO)
import RPi.GPIO as GPIO

LED_GREEN = 17   # GPIO 핀 번호
LED_YELLOW = 27
LED_RED = 22

def set_alert_led(alert_level: str):
    GPIO.output(LED_GREEN, alert_level == "NORMAL")
    GPIO.output(LED_YELLOW, alert_level in ("CAUTION", "WARNING"))
    GPIO.output(LED_RED, alert_level == "DANGER")
```

### [2] 스피커/부저 (Audio Alert)

`core/alert.py`의 `AlertManager._generate_voice_text()`가 생성하는 텍스트를
TTS(음성합성) 엔진으로 출력합니다.

| 등급 | 음성 출력 예시 |
|------|---------------|
| CAUTION | "2호기 방향 주의. 거리 8미터." |
| WARNING | "경고. 2호기 접근 중. 15초 후 충돌 예상. 거리 5미터." |
| DANGER | "위험! 1호기와 2호기 충돌 위험. 즉시 정지하세요. 거리 3미터." |

**구현 방법:**
- 경량 TTS: `pyttsx3` (오프라인) 또는 `gtts` (온라인)
- 산업용: 미리 녹음된 WAV 파일 재생 (지연 없음)
- 하드웨어: 산업용 앰프 스피커 (85dB 이상, 운전실 내 가청 거리)

### [3] 운전실 디스플레이 (Operator Display)

운전실에 설치된 터치 디스플레이에 해당 크레인 관련 정보만 표시합니다.

`core/alert.py`의 `AlertManager.get_alerts_for_crane()` 메서드를 사용하면
특정 크레인에 관련된 경고만 필터링할 수 있습니다.

표시 내용:
- 현재 크레인의 선회각, 기복각
- 인접 크레인과의 거리
- 경보 등급 (색상으로 구분)
- 경보 메시지 텍스트

### [4] 관제실 모니터 (Control Room Monitor)

이미 구현된 웹 UI(`templates/index.html`)를 대형 모니터에 전체 화면으로 표시합니다.

- 접속 방법: `http://서버IP:8000`
- 3D 시각화 (`static/js/three-scene.js`)로 현장 전체를 실시간 확인
- WebSocket(`server/websocket.py`)으로 0.2초마다 자동 갱신

### [5] 자동 정지 연동 (Emergency Stop Relay) - 미래 확장

**주의: 자동 정지 기능은 충분한 검증 후에만 활성화해야 합니다.**

자동 정지는 DANGER 등급에서 크레인의 선회 모터를 자동으로 정지시키는 기능입니다.

| 항목 | 내용 |
|------|------|
| 구현 방법 | GPIO → 안전 릴레이 → 크레인 제어 회로 |
| 릴레이 타입 | 이중화 안전 릴레이 (Safety Relay, SIL2 이상) |
| 동작 | DANGER 시 릴레이 차단 → 선회 모터 정지 |
| 복귀 | 수동 리셋 (운전자가 확인 후 수동 해제) |
| 인증 | 기능안전 인증 필요 (IEC 61508) |

**자동 정지를 활성화하기 전에 반드시:**
1. Stage 4 (현장 시범 운영)에서 최소 1개월 이상 경고 전용 모드 운영
2. 오탐율 0%에 근접한 것을 확인
3. 크레인 제조사와 협의하여 안전 인터페이스 설계
4. 기능안전(Functional Safety) 평가 실시

---

## 7. 설치 체크리스트

### 7.1 사전 현장 조사 (설치 1~2주 전)

```
□ 크레인 현황 파악
  □ 크레인 대수 확인
  □ 각 크레인의 모델명, 붐대 길이, 마스트 높이 확인
  □ 크레인 배치도 (평면도) 확보
  □ 크레인 간 거리 측정 (대략적)

□ 전원 환경 확인
  □ 크레인 운전실 내 220V AC 전원 확인
  □ 전원 안정성 확인 (정전 빈도)
  □ 분전반 위치 및 차단기 여유 용량 확인

□ 네트워크 환경 확인
  □ 현장 WiFi 존재 여부
  □ 크레인 운전실~관제실 간 무선 통달 거리 확인
  □ 금속 구조물에 의한 전파 차단 요소 파악
  □ LTE 통신 가능 여부 (백업용)

□ 설치 환경 확인
  □ 엣지 컴퓨터 설치 공간 (운전실 내 또는 마스트부)
  □ 센서 케이블 경로 확인 (마스트 내부 또는 외부)
  □ 방수 함체 설치 위치 선정
  □ 접근성 (유지보수를 위한 크레인 승강 장치)
```

### 7.2 센서 설치 위치

```
                 센서 설치 위치 상세도
                 =====================

                              풍속계 [D]
                              (크레인 최상부)
                                 │
                    ┌────────────┤
                    │ 운전실     │
                    │            │
                    │  [디스플레이][LED][부저]
                    │            │
                    │  [엣지PC]  │    ◄── 방수 함체 내 설치
                    └────────────┤
                                 │
          붐대 끝     붐대 기저부  │
            ●──────────●────────┤
                       │        │
               [B] 경사계       │
               (붐대 힌지부)    │
                                │
                       ─────────●  ◄── [A] 선회각 엔코더
                                │      (선회 베어링부)
                                │
                                │  마스트
                                │
                                │
                      ──────────●──────────  지면
                          기초 위치
                         [C] GPS/RTK 측량점

    센서 케이블 경로:
    ─────────────────
    선회각 엔코더 ──→ 마스트 내부 케이블 트레이 ──→ 엣지 컴퓨터
    기복각 경사계 ──→ 붐대~마스트 케이블 트레이 ──→ 엣지 컴퓨터
    풍속계 ─────→ 마스트 외부 케이블 ────────→ 엣지 컴퓨터
```

### 7.3 케이블 배선

```
□ 케이블 배선 체크리스트
  □ RS-485 케이블: 차폐 트위스트페어 (STP) 사용
  □ 케이블 길이 측정 (센서~엣지 컴퓨터)
    □ 선회각 엔코더: 약 __m
    □ 기복각 경사계: 약 __m
    □ 풍속계: 약 __m
  □ 전원 케이블: AWG 16~18 (24V DC)
  □ 케이블 트레이 또는 컨듀잇(배관) 확보
  □ 케이블 타이 및 클램프 준비
  □ 방수 글랜드(PG, M 타입) 준비
  □ 터미널 블록 및 커넥터 준비

□ 배선 시 주의사항
  □ 전원선과 신호선은 분리하여 배선 (노이즈 방지)
  □ RS-485 케이블은 양쪽 끝에 120옴 종단저항 연결
  □ 실드(차폐)는 한쪽 끝만 접지 (양쪽 접지 시 그라운드 루프 발생)
  □ 케이블 여유 길이 확보 (10~15%)
  □ 이동부(선회부)를 통과하는 케이블은 슬립링(slip ring) 사용
```

### 7.4 네트워크 연결 테스트

```
□ WiFi 연결 테스트
  □ 엣지 컴퓨터 → WiFi AP 연결 확인
  □ ping 테스트 (엣지 컴퓨터 → 관제실 서버)
  □ 지연 시간 측정 (50ms 이하 확인)
  □ 대역폭 테스트 (iperf3, 1Mbps 이상 확인)
  □ 24시간 연속 연결 안정성 테스트

□ WebSocket 연결 테스트
  □ 관제실 브라우저에서 http://서버IP:8000 접속 확인
  □ 실시간 데이터 수신 확인
  □ 연결 끊김/재연결 테스트
```

### 7.5 초기 설정 - config/settings.py 수정

현장 크레인에 맞게 `config/settings.py`를 수정합니다.

```python
# config/settings.py 수정 예시

# 실제 현장 크레인 사양으로 변경
DEFAULT_CRANES = [
    {
        "id": "TC-1",
        "name": "1호기",
        "base_x": 0.0,       # ← 측량 결과 입력 (미터, 현장 좌표계)
        "base_y": 0.0,       # ← 측량 결과 입력
        "mast_height": 52.0,  # ← 크레인 사양서에서 확인 (미터)
        "boom_length": 65.0,  # ← 크레인 사양서에서 확인 (미터)
        "initial_slew_angle": 0.0,
        "initial_luffing_angle": 0.0,
        "slew_speed": 0.0,
    },
    {
        "id": "TC-2",
        "name": "2호기",
        "base_x": 85.3,      # ← 측량 결과 입력
        "base_y": 12.7,      # ← 측량 결과 입력
        "mast_height": 48.0,
        "boom_length": 60.0,
        "initial_slew_angle": 0.0,
        "initial_luffing_angle": 0.0,
        "slew_speed": 0.0,
    },
]

# 경고 기준값 조정 (현장 여건에 맞게)
ALERT_THRESHOLDS = {
    "DANGER":  {"distance": 5.0,  "time_to_collision": 5.0},   # 현장 여건에 맞게 조정
    "WARNING": {"distance": 8.0,  "time_to_collision": 10.0},
    "CAUTION": {"distance": 15.0, "time_to_collision": 30.0},
    "NORMAL":  {"distance": 999.0, "time_to_collision": 999.0},
}
```

### 7.6 캘리브레이션 후 최종 확인

```
□ 최종 확인 체크리스트
  □ 각 센서 데이터 정상 수신 확인 (10Hz 이상)
  □ 선회각 0도 기준점 확인 (북쪽 방향과 일치)
  □ 기복각 0도 기준점 확인 (수평과 일치)
  □ 웹 UI에서 크레인 3D 위치가 실제와 일치하는지 확인
  □ 크레인을 수동으로 움직이며 경고 발생 테스트
  □ 비상 정지 → 경고 해제 확인
  □ 네트워크 끊김 시 경고 동작 확인
  □ 관제실 화면에서 전체 크레인 상태 확인
```

---

## 8. 캘리브레이션 (교정) 방법

### 8.1 선회각 영점(Zero Point) 설정

선회각의 0도 기준을 설정하는 작업입니다.
시스템에서는 0도 = 북쪽(Y축 양의 방향)으로 정의합니다.

**절차:**

1. 붐대를 현장 북쪽(또는 약속된 기준 방향)으로 정렬합니다.
2. 이 상태에서 엔코더의 원시값을 기록합니다.
3. 이 값을 오프셋(offset)으로 설정합니다.

```
                    N (북, 0도)
                    │
                    │  현재 붐대 방향
                    │╱
                    ●──────── E (동, 90도)
                   ╱│
                  ╱ │
                    │
                    S (남, 180도)

    영점 설정:
    ──────────
    1) 붐대를 정확히 북쪽으로 정렬
    2) 엔코더 원시값 기록 (예: 1024)
    3) offset = 1024
    4) 실제 각도 = (엔코더값 - offset) / 전체범위 * 360
```

**코드에서의 적용:**
```python
# sensor/reader.py의 read_slew_angle() 내부
raw_value = self._read_encoder()
offset = self.slew_offset  # 캘리브레이션에서 결정된 값
angle = ((raw_value - offset) / MAX_ENCODER_VALUE) * 360.0
angle = angle % 360.0  # 0~360도 범위로 정규화
```

### 8.2 붐대 길이 및 마스트 높이 검증

`config/settings.py`에 입력한 `boom_length`와 `mast_height`가 실제와 정확히 일치하는지 확인합니다.

**검증 방법:**

1. 크레인 사양서(spec sheet)에서 공칭 값 확인
2. 실측: 레이저 거리계로 마스트 높이 측정
3. 실측: 붐대를 수평(기복각 0도)으로 놓고 끝점까지 수평 거리 측정

**주의**: 마스트 높이는 크레인 모델에 따라 "지면~마스트 꼭대기" 또는 "기초 상면~마스트 꼭대기"
등 측정 기준이 다를 수 있습니다. 시스템에서 사용하는 값은 **지면(기초 상면)에서 붐대 피벗
(회전 중심)까지의 높이**입니다.

### 8.3 기초 좌표(base_x, base_y) 설정

크레인의 기초 위치를 현장 좌표계로 정확히 입력합니다.

**방법 1: GPS/RTK 측량**
```
1. RTK 수신기를 크레인 기초 중심에 설치
2. RTK Fix 상태에서 위경도 좌표 기록
3. 모든 크레인을 동일한 기준으로 측량
4. 위경도 → 현장 로컬 좌표계(TM 좌표)로 변환
5. 첫 번째 크레인을 원점(0,0)으로 설정하고 나머지를 상대 좌표로 환산
```

**방법 2: 토탈스테이션/줄자 (간이 방법)**
```
1. 현장 기준점(BM: Bench Mark) 확인
2. 토탈스테이션으로 각 크레인 기초 중심까지 거리와 방위각 측정
3. 거리와 방위각으로 직교 좌표(x, y) 계산

   base_x = 거리 * sin(방위각)
   base_y = 거리 * cos(방위각)
```

**방법 3: 도면 기반 (가장 간단하지만 정확도 낮음)**
```
1. 건축 배치도에서 크레인 기초 위치 확인
2. 도면상 좌표를 미터 단위로 읽어서 입력
3. 오차가 1~2m 이상일 수 있으므로 시범 운영 중 보정 필요
```

**좌표 입력 예시:**
```
    현장 좌표계 (Y축 = 북쪽)

    Y (북) ▲
           │
    70.0 ──┤           ● TC-3 (40.0, 70.0)
           │
           │
           │
     0.0 ──● TC-1 ────────────────● TC-2 (80.0, 0.0)
           │  (0.0, 0.0)
           └──┬──────────┬────────┬──▶ X (동)
             0.0       40.0     80.0
```

이 경우 `config/settings.py`에:
```python
DEFAULT_CRANES = [
    {"id": "TC-1", "base_x": 0.0,  "base_y": 0.0,  ...},
    {"id": "TC-2", "base_x": 80.0, "base_y": 0.0,  ...},
    {"id": "TC-3", "base_x": 40.0, "base_y": 70.0, ...},
]
```

### 8.4 경보 임계값(Threshold) 현장 맞춤 조정

`config/settings.py`의 `ALERT_THRESHOLDS`를 현장 상황에 맞게 조정합니다.

**조정 시 고려사항:**

| 요소 | 임계값 넓혀야 할 때 | 임계값 좁혀야 할 때 |
|------|-------------------|-------------------|
| 크레인 간 거리 | 크레인이 가까이 설치됨 | 크레인이 멀리 설치됨 |
| 작업 속도 | 고속 작업 | 저속 정밀 작업 |
| 풍속 | 바람이 강한 현장 | 바람이 약한 현장 |
| 하중 | 중량물 양중 | 경량물 양중 |
| 운전자 숙련도 | 초보 운전자 | 숙련 운전자 |

**권장 초기값 (보수적):**
```python
ALERT_THRESHOLDS = {
    "DANGER":  {"distance": 5.0,  "time_to_collision": 8.0},
    "WARNING": {"distance": 10.0, "time_to_collision": 15.0},
    "CAUTION": {"distance": 20.0, "time_to_collision": 30.0},
    "NORMAL":  {"distance": 999.0, "time_to_collision": 999.0},
}
```

시범 운영(Stage 4) 기간 동안 오탐이 많으면 거리를 줄이고,
미탐이 발생하면 거리를 늘려서 최적값을 찾습니다.

---

## 9. 유지보수 가이드

### 9.1 정기 캘리브레이션 일정

| 항목 | 주기 | 방법 |
|------|------|------|
| 선회각 영점 확인 | 1개월 | 붐대를 기준 방향으로 정렬 후 오차 측정 |
| 기복각 영점 확인 | 1개월 | 붐대를 수평으로 놓고 센서 값 확인 |
| 기초 좌표 확인 | 6개월 또는 지반 변동 시 | 재측량 |
| 전체 시스템 교정 | 6개월 | 모든 항목 일괄 점검 |

### 9.2 센서 건강 모니터링

센서 이상을 조기에 감지하기 위해 다음 항목을 모니터링합니다.

**자동 모니터링 항목:**

| 항목 | 정상 범위 | 이상 판정 | 조치 |
|------|-----------|-----------|------|
| 센서 데이터 수신 주기 | 100ms 이내 | 500ms 이상 지연 | 통신 케이블 점검 |
| 선회각 변화율 | < 5도/초 | > 10도/초 (비정상적 급변) | 센서 또는 연결부 점검 |
| 기복각 범위 | 0~80도 | 범위 초과 | 경사계 재교정 |
| 센서 무응답 | - | 3초 이상 무응답 | 관제실 경고 + 현장 점검 |
| 데이터 노이즈 | 표준편차 < 0.5도 | 표준편차 > 2도 | 케이블/접지 점검 |

**구현 팁:**
`sensor/reader.py`의 `SensorEngine.start()` 루프 내에서 위 항목을 주기적으로 검사하고,
이상 발견 시 `core/alert.py`와 유사한 메커니즘으로 시스템 경고를 발생시킵니다.

### 9.3 로그 검토

시스템은 두 가지 로그를 생성합니다.

**1) 이벤트 로그 (경보 이력)**

`core/collision.py`의 `CollisionEngine.event_log`에 경보 등급 변경 이력이 저장됩니다.
- 최대 1000건까지 메모리에 보관 (`max_event_log_size = 1000`)
- API로 조회 가능: `GET /api/status` → `recent_events`

실제 운영에서는 이 로그를 파일이나 데이터베이스에 영구 저장하도록 확장해야 합니다:
- 일별 로그 파일: `logs/2026-02-02_events.json`
- 또는 SQLite/PostgreSQL 데이터베이스

**2) 서버 로그 (시스템 동작 기록)**

`uvicorn` 서버의 접속 로그와 에러 로그가 터미널에 출력됩니다.
운영 환경에서는 파일로 리다이렉트합니다:

```bash
python run.py >> logs/server.log 2>&1
```

**로그 검토 주기:**

| 항목 | 주기 | 확인 내용 |
|------|------|-----------|
| 일일 경보 이력 | 매일 | 비정상적 경보 패턴, 반복 경보 |
| 주간 통계 | 매주 | 경보 등급별 발생 건수, 추이 분석 |
| 월간 보고서 | 매월 | 오탐율, 시스템 가동률, 센서 이상 건수 |
| 서버 에러 로그 | 매주 | 오류 메시지, 연결 끊김 횟수 |

### 9.4 소프트웨어 업데이트

| 항목 | 방법 |
|------|------|
| 코드 업데이트 | `git pull` 후 서비스 재시작 |
| Python 패키지 업데이트 | `pip install -r requirements.txt --upgrade` |
| OS 보안 패치 | `sudo apt update && sudo apt upgrade` (월 1회) |
| 백업 | 업데이트 전 `config/settings.py` 백업 필수 |

**업데이트 절차:**
```
1. 관제실에 업데이트 사전 공지 (크레인 작업 중지 시간 협의)
2. config/settings.py 백업
3. git pull (새 코드 받기)
4. 테스트 환경에서 먼저 실행 확인
5. 서비스 재시작
6. 동작 확인 (웹 UI, 센서 데이터, 경보)
7. 업데이트 완료 보고
```

---

## 10. 안전 규정 및 인증

### 10.1 관련 한국 법규

| 법규 | 관련 조항 | 내용 |
|------|-----------|------|
| **건설기계관리법** | 제13조 (안전기준) | 건설기계의 안전 기준 준수 의무 |
| **산업안전보건법** | 제38조 (안전조치) | 사업주의 안전조치 의무 (양중기 작업 시) |
| **산업안전보건기준에 관한 규칙** | 제132조~제143조 | 양중기 작업 시 안전 기준 (과부하 방지, 신호수 배치 등) |
| **건설기술 진흥법** | 제62조 (안전관리) | 건설공사 안전관리 계획 수립 의무 |
| **위험성평가 지침** (KOSHA Guide) | X-1-2012 | 건설현장 양중기 위험성 평가 |

**핵심 요점:**
- 타워크레인에 안전장치를 추가 설치할 때는 크레인 제조사의 승인이 필요합니다.
- 안전 관련 장치를 임의로 개조하면 법적 책임 문제가 발생할 수 있습니다.
- 본 시스템은 **보조 안전 장치(경고 시스템)**이며, 기존 안전장치를 대체하지 않습니다.
- 자동 정지 기능을 연동할 경우, 반드시 제조사 협의와 안전 인증을 받아야 합니다.

### 10.2 인증 관련 사항

| 인증 | 내용 | 필요 여부 |
|------|------|-----------|
| **KC 인증** | 전기용품 및 생활용품 안전관리법에 따른 인증. 엣지 컴퓨터, 전원장치 등 전자 장비에 해당. | 상용 판매 시 필요 |
| **CE 마킹** | 유럽 수출 시 필요. 기계류 지침(2006/42/EC)에 해당할 수 있음. | 수출 시 필요 |
| **IEC 61508 (기능안전)** | 자동 정지 기능을 포함하는 안전 관련 시스템에 필요. SIL(Safety Integrity Level) 등급 결정 필요. | 자동 정지 연동 시 필요 |
| **KS C IEC 61131** | PLC를 사용하는 경우 프로그래밍 표준. | PLC 사용 시 참고 |

**자체 개발 시스템(경고 전용)의 경우:**
- 경고만 출력하고 자동 정지 기능이 없는 경우, 기능안전 인증은 필수가 아닙니다.
- 다만, 현장 안전관리 계획서에 본 시스템의 역할과 한계를 명확히 기술해야 합니다.
- "본 시스템은 참고용 보조 장치이며, 최종 안전 판단은 운전자가 수행합니다." 등의 면책 조항을 포함합니다.

### 10.3 기록 유지 요구사항

산업안전보건법에 따라 다음 기록을 유지해야 합니다.

| 기록 항목 | 보관 기간 | 형식 |
|-----------|-----------|------|
| 일일 경보 발생 기록 | 3년 | 전자 로그 파일 |
| 센서 캘리브레이션 기록 | 3년 | 교정 성적서 |
| 시스템 점검/유지보수 기록 | 3년 | 점검일지 |
| 운전자 교육 기록 | 3년 | 교육 수료증 |
| 시스템 설치/변경 이력 | 영구 | 설치 보고서 |

---

## 11. 비용 추정

### 11.1 크레인 1대당 센서 키트 비용

| 항목 | 최소 사양 | 권장 사양 | 비고 |
|------|-----------|-----------|------|
| 선회각 엔코더 (절대형) | 30만원 | 100만원 | 12비트 / 16비트 |
| 기복각 경사계 | 20만원 | 60만원 | 아날로그 / 디지털 |
| 풍속계 (공유 가능) | 30만원 | 100만원 | 초음파식 |
| 엣지 컴퓨터 (RPi4 키트) | 10만원 | 15만원 | 산업용PC 선택 시 50~150만원 |
| RS-485 통신 모듈 | 3만원 | 10만원 | HAT / USB 변환기 |
| UPS/배터리 | 5만원 | 15만원 | HAT형 / 독립형 |
| 방수 함체 (IP65) | 5만원 | 15만원 | 크기에 따라 |
| 운전실 디스플레이 | 15만원 | 40만원 | 7인치 / 10인치 |
| LED 신호등 | 3만원 | 10만원 | 3색 타워 램프 |
| 부저/스피커 | 2만원 | 5만원 | 앰프 포함 |
| 케이블/커넥터 | 10만원 | 30만원 | 차폐 케이블, M12 커넥터 |
| **소계 (1대당)** | **약 133만원** | **약 400만원** | |

### 11.2 공용 장비 비용

| 항목 | 최소 사양 | 권장 사양 | 비고 |
|------|-----------|-----------|------|
| 관제실 서버 PC | - | 100만원 | 별도 서버가 필요한 경우 |
| 대형 모니터 (관제실) | 30만원 | 80만원 | 32인치 이상 |
| 네트워크 장비 (WiFi AP) | 5만원 | 30만원 | 산업용 AP |
| GPS/RTK 측량 (외주) | 50만원 | 100만원 | 1회 비용 |
| **소계** | **약 85만원** | **약 310만원** | |

### 11.3 설치 인건비

| 항목 | 소요 기간 | 비용 (추정) |
|------|-----------|------------|
| 센서 설치 (크레인 1대) | 1~2일 | 50만~100만원 |
| 케이블 배선 | 1일/대 | 30만~50만원 |
| 소프트웨어 설정/캘리브레이션 | 1일 | 30만~50만원 |
| 시운전 및 조정 | 2~3일 | 50만~100만원 |
| **소계 (1대당)** | **4~7일** | **약 160만~300만원** |

### 11.4 연간 유지보수 비용

| 항목 | 주기 | 연간 비용 (추정) |
|------|------|-----------------|
| 정기 캘리브레이션 | 월 1회 | 120만~240만원 (10만~20만원/회) |
| 센서 교체/수리 | 수시 | 50만~100만원 |
| 소프트웨어 유지보수 | 상시 | 100만~200만원 |
| 네트워크 유지 | 상시 | 12만~36만원 (통신료 포함) |
| **연간 합계** | | **약 282만~576만원** |

### 11.5 전체 비용 요약 (크레인 3대 기준)

| 항목 | 최소 | 권장 |
|------|------|------|
| 센서 키트 (3대) | 399만원 | 1,200만원 |
| 공용 장비 | 85만원 | 310만원 |
| 설치 인건비 (3대) | 480만원 | 900만원 |
| **초기 투자 합계** | **약 964만원** | **약 2,410만원** |
| 연간 유지보수 | 282만원 | 576만원 |

**참고**: 위 비용은 2026년 기준 추정치이며, 실제 비용은 현장 여건, 센서 브랜드, 인건비 등에 따라 달라질 수 있습니다. 크레인 제조사의 OEM 옵션을 활용하면 센서 비용이 절감될 수 있습니다.

---

## 부록: 용어 대조표

| 한국어 | 영어 | 시스템 변수명 | 설명 |
|--------|------|-------------|------|
| 선회각 | Slew Angle | `slew_angle` | 크레인 상부 회전각 (도) |
| 기복각 | Luffing Angle | `luffing_angle` | 붐대 경사각 (도) |
| 선회 속도 | Slew Speed | `slew_speed` | 선회 각속도 (도/초) |
| 기복 속도 | Luffing Speed | `luffing_speed` | 기복 각속도 (도/초) |
| 마스트 높이 | Mast Height | `mast_height` | 기초~붐대 피벗 높이 (m) |
| 붐대 길이 | Boom Length | `boom_length` | 붐대 전체 길이 (m) |
| 기초 좌표 | Base Position | `base_x`, `base_y` | 크레인 기초 위치 (m) |
| 작업 반경 | Working Radius | `working_radius` | 현재 수평 도달 거리 (m) |
| 안전 여유 거리 | Safety Margin | `SAFETY_MARGIN_METERS` | 충돌 판정 여유 거리 (m) |
| 예상 충돌 시간 | Time to Collision | `time_to_collision` | 충돌까지 남은 시간 (초) |

---

## 부록: 자주 묻는 질문 (FAQ)

### Q1. 시뮬레이션과 실제 센서를 동시에 사용할 수 있나요?

네. 일부 크레인은 실제 센서로, 나머지는 시뮬레이션으로 운영할 수 있습니다.
`SensorEngine`에서 센서가 연결되지 않은 크레인은 수동으로 각도를 입력하거나,
시뮬레이션 값을 사용하도록 하이브리드 모드를 구현할 수 있습니다.

### Q2. 크레인이 이동식(Crawler Crane)인 경우에도 사용할 수 있나요?

원칙적으로 가능하지만, 기초 좌표(`base_x`, `base_y`)가 변하므로 GPS/RTK 상시 장착이
필요합니다. 현재 시스템은 타워크레인(기초 고정)에 최적화되어 있습니다.

### Q3. 인터넷 연결이 필요한가요?

아닙니다. 본 시스템은 **완전히 오프라인**으로 동작합니다.
엣지 컴퓨터와 관제실 사이의 현장 내부 네트워크(LAN)만 있으면 됩니다.
인터넷은 소프트웨어 업데이트 시에만 필요합니다.

### Q4. 동시에 몇 대의 크레인까지 지원하나요?

소프트웨어적으로는 제한이 없지만, 크레인 수가 늘어나면 충돌 검사 쌍이 기하급수적으로 늘어납니다.
(N대 크레인 → N*(N-1)/2 쌍의 검사)

| 크레인 수 | 검사 쌍 수 | 성능 |
|-----------|-----------|------|
| 2대 | 1쌍 | 문제없음 |
| 3대 | 3쌍 | 문제없음 |
| 5대 | 10쌍 | 문제없음 |
| 10대 | 45쌍 | Raspberry Pi 4에서도 가능 |
| 20대 | 190쌍 | 서버급 PC 권장 |

### Q5. 시스템 장애 시 크레인 운전은 어떻게 하나요?

본 시스템은 **보조 안전 장치**입니다. 시스템이 작동하지 않더라도 크레인은 정상적으로
운전할 수 있습니다. 다만, 시스템 장애 시 관제실에 알림을 보내고, 신호수(Signal Person)를
추가 배치하는 등 대체 안전 조치를 시행해야 합니다.

---

> **문서 끝**
>
> 이 가이드에 대한 문의사항이나 개선 제안은 프로젝트 이슈 트래커에 등록해 주세요.
> 현장 적용 시에는 반드시 안전 관리자와 크레인 전문가의 검토를 받으시기 바랍니다.
