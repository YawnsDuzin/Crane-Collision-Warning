# 08. 위험등급 판정 로직

## 목차

1. [개요: 4단계 경보 시스템](#1-개요-4단계-경보-시스템)
2. [검사 파이프라인: _check_pair()의 4단계](#2-검사-파이프라인-_check_pair의-4단계)
3. [거리 기반 등급 판정](#3-거리-기반-등급-판정)
4. [시간 기반 등급 판정](#4-시간-기반-등급-판정)
5. ["둘 중 더 위험한 쪽" 규칙](#5-둘-중-더-위험한-쪽-규칙)
6. [등급 우선순위 시스템 (LEVEL_PRIORITY)](#6-등급-우선순위-시스템-level_priority)
7. [등급 변화 감지와 이벤트 기록](#7-등급-변화-감지와-이벤트-기록)
8. [AlertManager: 결과를 사람이 읽는 메시지로](#8-alertmanager-결과를-사람이-읽는-메시지로)
9. [크레인별 종합 등급 계산 (get_overall_status)](#9-크레인별-종합-등급-계산-get_overall_status)
10. [전체 판정 흐름도](#10-전체-판정-흐름도)

---

## 1. 개요: 4단계 경보 시스템

크레인 충돌 예측 시스템은 **4단계 경보 등급**을 사용합니다.
신호등과 비슷하다고 생각하면 쉽습니다.

### 1.1 등급 한눈에 보기

```
 안전 ◀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━▶ 위험

 ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
 │  NORMAL   │  │ CAUTION  │  │ WARNING  │  │  DANGER  │
 │  (정상)   │  │  (주의)  │  │  (경고)  │  │  (위험)  │
 │           │  │          │  │          │  │          │
 │  #00CC00  │  │ #FFD700  │  │ #FF8C00  │  │ #FF0000  │
 │  초록색   │  │  노란색  │  │  주황색  │  │  빨간색  │
 └──────────┘  └──────────┘  └──────────┘  └──────────┘
    안전          알림        속도 제한     비상 정지
```

### 1.2 각 등급의 의미와 대응 행동

| 등급 | 한글명 | 색상 코드 | 색상 | 의미 | 현장 대응 |
|------|--------|-----------|------|------|-----------|
| NORMAL | 정상 | `#00CC00` | 초록 | 충돌 위험 없음 | 정상 작업 계속 |
| CAUTION | 주의 | `#FFD700` | 노랑 | 접근 감지 | 운전자에게 알림 |
| WARNING | 경고 | `#FF8C00` | 주황 | 위험 접근 | 선회 속도 줄이기 |
| DANGER | 위험 | `#FF0000` | 빨강 | 충돌 임박 | 즉시 비상 정지 |

### 1.3 일상생활에 비유하면?

```
 자동차 운전에 비유해 봅시다:

 NORMAL  = 앞에 차가 없어서 자유롭게 달리는 상태
 CAUTION = 앞에 차가 보이기 시작 (주의 깊게 관찰)
 WARNING = 앞차와 가까워짐 (브레이크에 발 올리기)
 DANGER  = 앞차와 매우 가까움 (급브레이크!)
```

### 1.4 관련 소스 코드 위치

이 등급들은 `core/collision.py` 파일 상단에 상수로 정의되어 있습니다:

```python
# core/collision.py (52~55행)
LEVEL_NORMAL  = "NORMAL"     # 정상 - 안전
LEVEL_CAUTION = "CAUTION"    # 주의 - 알림
LEVEL_WARNING = "WARNING"    # 경고 - 속도 제한
LEVEL_DANGER  = "DANGER"     # 위험 - 비상 정지
```

그리고 각 등급의 색상은 `config/settings.py`에 정의되어 있습니다:

```python
# config/settings.py (51~56행)
ALERT_COLORS = {
    "DANGER":  "#FF0000",  # 빨강
    "WARNING": "#FF8C00",  # 주황
    "CAUTION": "#FFD700",  # 노랑
    "NORMAL":  "#00CC00",  # 초록
}
```

---

## 2. 검사 파이프라인: _check_pair()의 4단계

두 크레인이 위험한지 판단하려면 한 번에 답을 내리지 않고, **4단계 검사**를 순서대로
수행합니다. 앞 단계에서 "안전하다"라고 판단되면 뒤 단계는 생략합니다.
이렇게 하면 불필요한 계산을 줄일 수 있습니다.

이 로직은 `core/collision.py`의 `_check_pair()` 함수(201~305행)에 구현되어 있습니다.

### 2.1 파이프라인 전체 흐름

```
 입력: 크레인 A, 크레인 B
 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

 ┌─────────────────────────────────────────────────────┐
 │  1단계: 작업 반경 중첩 확인  (계산 비용: ★☆☆☆☆)    │
 │                                                     │
 │  두 크레인의 작업 범위가 겹치는가?                   │
 │  (원과 원이 겹치는지만 확인 - 아주 빠름)            │
 └───────────────────────┬─────────────────────────────┘
                         │
              ┌──────────┴──────────┐
              │ 겹치는가?           │
              ├──────────┬──────────┤
              │  아니오  │    예    │
              ▼          ▼          │
       ┌──────────┐                 │
       │  NORMAL  │                 │
       │  (종료)  │                 │
       └──────────┘                 │
                                    ▼
 ┌─────────────────────────────────────────────────────┐
 │  2단계: 현재 거리 측정  (계산 비용: ★★★☆☆)         │
 │                                                     │
 │  2-a: 붐대 끝점 간 거리 (boom tip distance)         │
 │  2-b: 붐대 선분 간 최소 거리 (segment distance)     │
 └───────────────────────┬─────────────────────────────┘
                         │
                         ▼
 ┌─────────────────────────────────────────────────────┐
 │  3단계: 미래 궤적 예측  (계산 비용: ★★★★★)         │
 │                                                     │
 │  크레인이 움직이고 있는 경우에만 수행               │
 │  - 0.5초 간격으로 30초 후까지 미래 위치 계산        │
 │  - 가장 가까워지는 시점과 거리 파악                 │
 │  - 충돌 예상 시간(TTC) 계산                         │
 └───────────────────────┬─────────────────────────────┘
                         │
                         ▼
 ┌─────────────────────────────────────────────────────┐
 │  4단계: 위험 등급 판정  (계산 비용: ★☆☆☆☆)         │
 │                                                     │
 │  거리 기반 등급 + 시간 기반 등급                     │
 │  → 둘 중 더 위험한 등급을 최종 결과로 채택          │
 └─────────────────────────────────────────────────────┘

 출력: CollisionCheckResult (등급, 거리, 충돌 예상 시간 등)
```

### 2.2 1단계: 작업 반경 중첩 확인 (빠른 사전 필터)

가장 먼저 "두 크레인의 작업 범위가 겹치는가?"를 확인합니다.

```
 크레인A의 작업 범위            크레인B의 작업 범위

        ╭─────╮                      ╭─────╮
       ╱       ╲                    ╱       ╲
      │    A    │                  │    B    │
       ╲       ╱                    ╲       ╱
        ╰─────╯                      ╰─────╯

     ──────────── 거리가 멀다 ────────────

     → 겹치지 않음 → 물리적으로 충돌 불가 → "NORMAL" 즉시 반환
```

```
 작업 범위가 겹치는 경우:

             ╭─────╮
            ╱       ╲╭─────╮
           │    A   ╱│      ╲
            ╲    ╱╱  │   B   │
             ╰──╱╯   ╲      ╱
                       ╰─────╯

     → 겹침 있음 → 2단계로 진행하여 정밀 검사
```

이 단계가 있는 이유는 **성능 최적화**입니다. 작업 범위가 겹치지 않는 크레인 쌍은
뒤의 비용이 큰 계산을 할 필요가 없기 때문입니다.

해당 소스 코드 (`core/collision.py`, 249~264행):

```python
# 1단계: 작업 반경 중첩 확인 (빠른 사전 필터)
result.overlap_exists = check_working_radius_overlap(
    crane_a.base_x, crane_a.base_y, crane_a.get_max_working_radius(),
    crane_b.base_x, crane_b.base_y, crane_b.get_max_working_radius(),
)

if not result.overlap_exists:
    # 작업 반경이 겹치지 않으면 물리적으로 충돌 불가
    result.alert_level = LEVEL_NORMAL
    return result   # ← 여기서 즉시 종료! 2~4단계를 건너뜀
```

### 2.3 2단계: 현재 거리 측정

작업 반경이 겹치면, 실제로 붐대가 얼마나 가까운지 정밀하게 측정합니다.
두 가지 거리를 모두 계산합니다.

```
 [2-a] 붐대 끝점 간 거리 (boom_tip_distance)

 크레인A                           크레인B
    |                                 |
    |    붐대A                        |    붐대B
    |  ╱                              |  ╱
    | ╱                               | ╱
    |╱                                |╱
   기둥A         ◀── 이 거리 ──▶     기둥B
             (끝점과 끝점 사이)

 [2-b] 붐대 선분 간 최소 거리 (current_distance)

 크레인A                    크레인B
    |                          |
    |    붐대A                 |    붐대B
    |  ╱          ◀─이 거리─▶  |  ╱
    | ╱            (선분 사이)  | ╱
    |╱                         |╱
   기둥A                      기둥B

 선분 간 최소 거리가 더 정확합니다!
 붐대 끝점이 멀더라도, 붐대 중간 부분이 가까울 수 있기 때문입니다.
```

해당 소스 코드 (`core/collision.py`, 266~280행):

```python
# 2-a: 붐대 끝점 간 거리
tip_a = crane_a.get_boom_tip_position()
tip_b = crane_b.get_boom_tip_position()
result.boom_tip_distance = calculate_distance_3d(tip_a, tip_b)

# 2-b: 붐대 선분 간 최소 거리 (더 정확한 측정)
seg_a = crane_a.get_boom_segment()
seg_b = crane_b.get_boom_segment()
result.current_distance = closest_distance_between_segments(
    seg_a[0], seg_a[1], seg_b[0], seg_b[1]
)
```

### 2.4 3단계: 미래 궤적 예측 (움직이는 경우만)

크레인이 **움직이고 있을 때만** 미래 궤적을 예측합니다.
정지해 있으면 현재 거리만으로 판정하면 됩니다.

```
 "움직이고 있다"의 기준:

 선회 속도(slew_speed)가 0.01도/초 이상이거나
 기복 속도(luffing_speed)가 0.01도/초 이상이면
 → "움직이고 있다"

 왜 0이 아니라 0.01인가?
 → 컴퓨터는 소수점 계산에서 아주 작은 오차가 생길 수 있음
 → 0.000000001 같은 값을 "움직인다"로 판단하면 안 되므로
 → 0.01이라는 작은 기준값(threshold)을 사용
```

움직이고 있다면, `_predict_collision()` 함수가 호출됩니다:

```
 현재 시점      0.5초 후     1.0초 후     ...      30초 후
 ──────────────────────────────────────────────────────────
 A의 위치:   ●━━━━━●━━━━━●━━━━━ ... ━━━━━●
 B의 위치:   ●━━━━━●━━━━━●━━━━━ ... ━━━━━●

 각 시점에서 A와 B 사이 거리를 계산:
   0.5초: 15.2m
   1.0초: 13.8m
   1.5초: 12.1m   ← 점점 가까워지는 중
   ...
   8.0초:  1.5m   ← SAFETY_MARGIN(2.0m) 이하! → 충돌 예상 시간 = 8초
   ...
  12.0초:  0.8m   ← 최소 거리
   ...
  30.0초:  9.3m   ← 다시 멀어짐

 결과:
   time_to_collision = 8.0  (충돌 예상 시간)
   min_distance = 0.8       (예측 기간 내 최소 거리)
   min_distance_time = 12.0 (최소 거리 시점)
```

해당 소스 코드 (`core/collision.py`, 286~298행):

```python
is_moving = (
    abs(crane_a.slew_speed) > 0.01
    or abs(crane_b.slew_speed) > 0.01
    or abs(crane_a.luffing_speed) > 0.01
    or abs(crane_b.luffing_speed) > 0.01
)

if is_moving:
    prediction = self._predict_collision(crane_a, crane_b)
    result.time_to_collision = prediction["time_to_collision"]
    result.min_predicted_distance = prediction["min_distance"]
    result.min_predicted_time = prediction["min_distance_time"]
```

### 2.5 4단계: 위험 등급 판정

2단계에서 구한 **현재 거리**와 3단계에서 구한 **충돌 예상 시간**을 종합하여
최종 위험 등급을 결정합니다. 이 부분이 이 문서의 핵심이며,
다음 장에서 자세히 설명합니다.

```python
# core/collision.py, 300~303행
result.alert_level = self._determine_alert_level(result)
```

---

## 3. 거리 기반 등급 판정

`_determine_alert_level()` 함수(378~420행)는 먼저 **현재 거리**를 기준으로
등급을 판정합니다.

### 3.1 기준값 (config/settings.py)

```python
ALERT_THRESHOLDS = {
    "DANGER":  {"distance": 3.0,  ...},   # 3m 이하 → 위험
    "WARNING": {"distance": 5.0,  ...},   # 5m 이하 → 경고
    "CAUTION": {"distance": 10.0, ...},   # 10m 이하 → 주의
    "NORMAL":  {"distance": 999.0,...},   # 그 외 → 정상
}
```

### 3.2 판정 규칙

| 조건 | 결과 등급 |
|------|-----------|
| 거리 <= 3.0m | DANGER (위험) |
| 거리 <= 5.0m | WARNING (경고) |
| 거리 <= 10.0m | CAUTION (주의) |
| 거리 > 10.0m | NORMAL (정상) |

> **중요:** 조건은 위에서부터 순서대로 확인합니다. 거리가 2m이면 첫 번째 조건
> (`<= 3.0m`)에 이미 해당하므로 DANGER가 됩니다. 두 번째 조건(`<= 5.0m`)까지
> 내려가지 않습니다.

### 3.3 수직선 다이어그램 (Number Line)

거리를 수직선 위에 놓으면, 어느 구간에 해당하는지 한눈에 볼 수 있습니다:

```
 거리(m)
  0  1  2  3  4  5  6  7  8  9  10  11  12 ...
  ├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼───┼───┼──── ...
  │           │        │              │
  │  DANGER   │WARNING │   CAUTION    │  NORMAL
  │  (위험)   │(경고)  │   (주의)     │  (정상)
  │           │        │              │
  ◀━━━━━━━━━▶◀━━━━━━━▶◀━━━━━━━━━━━━▶◀━━━━━━━━▶
   0m ~ 3m    3m ~ 5m   5m ~ 10m      10m 초과

  구체적 예시:

  거리 = 2.0m   →  ●
  0──┼──●─┼──┼──┼──┼──┼──┼──┼──┼───┼──
     │  DANGER  │
     └───→ 결과: DANGER (위험)

  거리 = 4.5m   →           ●
  0──┼──┼──┼──┼──●──┼──┼──┼──┼──┼───┼──
              │ WARNING │
              └───→ 결과: WARNING (경고)

  거리 = 7.0m   →                    ●
  0──┼──┼──┼──┼──┼──┼──●──┼──┼──┼───┼──
                    │   CAUTION   │
                    └───→ 결과: CAUTION (주의)

  거리 = 15.0m  →                              ●
  0──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼───┼── ... ──●──
                                  │  NORMAL
                                  └───→ 결과: NORMAL (정상)
```

### 3.4 해당 소스 코드

```python
# core/collision.py, 394~404행
distance = result.current_distance

# 거리 기반 등급 판정
distance_level = LEVEL_NORMAL                                      # 기본값: 정상
if distance <= ALERT_THRESHOLDS["DANGER"]["distance"]:             # <= 3.0m
    distance_level = LEVEL_DANGER
elif distance <= ALERT_THRESHOLDS["WARNING"]["distance"]:          # <= 5.0m
    distance_level = LEVEL_WARNING
elif distance <= ALERT_THRESHOLDS["CAUTION"]["distance"]:          # <= 10.0m
    distance_level = LEVEL_CAUTION
# 위 어디에도 해당하지 않으면 LEVEL_NORMAL 유지 (> 10.0m)
```

### 3.5 경계값 (Edge Case) 정리

경계에 딱 걸리는 값은 어떻게 될까요?

| 거리 값 | 조건 충족 | 결과 |
|---------|-----------|------|
| 3.0m | `<= 3.0` 충족 | DANGER |
| 3.01m | `<= 3.0` 미충족, `<= 5.0` 충족 | WARNING |
| 5.0m | `<= 5.0` 충족 | WARNING |
| 5.01m | `<= 5.0` 미충족, `<= 10.0` 충족 | CAUTION |
| 10.0m | `<= 10.0` 충족 | CAUTION |
| 10.01m | 모두 미충족 | NORMAL |

> **핵심:** `<=` (이하) 연산자를 사용하므로 경계값 자체는 **더 위험한 쪽**에 포함됩니다.
> 예를 들어 정확히 3.0m이면 WARNING이 아니라 DANGER입니다.

---

## 4. 시간 기반 등급 판정

거리 기반 판정 다음으로, **충돌 예상 시간(TTC: Time To Collision)**을 기준으로도
등급을 판정합니다.

### 4.1 TTC란?

```
 TTC (Time To Collision) = 충돌 예상 시간

 "현재 속도를 유지하면, 몇 초 후에 두 크레인이 충돌하는가?"

 예시:
   TTC = 8초   →  8초 후에 충돌 예상
   TTC = 25초  →  25초 후에 충돌 예상
   TTC = None  →  현재 속도로는 충돌 예상 없음 (정지 상태이거나
                   서로 멀어지는 방향으로 움직이는 경우)
```

### 4.2 기준값 (config/settings.py)

```python
ALERT_THRESHOLDS = {
    "DANGER":  {..., "time_to_collision": 5.0},    # 5초 이하 → 위험
    "WARNING": {..., "time_to_collision": 10.0},   # 10초 이하 → 경고
    "CAUTION": {..., "time_to_collision": 30.0},   # 30초 이하 → 주의
    "NORMAL":  {..., "time_to_collision": 999.0},  # 그 외 → 정상
}
```

### 4.3 판정 규칙

| 조건 | 결과 등급 |
|------|-----------|
| TTC가 None (충돌 예상 없음) | NORMAL (정상) |
| TTC <= 5초 | DANGER (위험) |
| TTC <= 10초 | WARNING (경고) |
| TTC <= 30초 | CAUTION (주의) |
| TTC > 30초 | NORMAL (정상) |

### 4.4 시간축 다이어그램

```
 충돌 예상 시간(초)
 0   5   10   15   20   25   30   35   40  ...
 ├───┼────┼────┼────┼────┼────┼────┼────┼──── ...
 │        │         │                   │
 │ DANGER │ WARNING │     CAUTION       │  NORMAL
 │ (위험) │ (경고)  │     (주의)        │  (정상)
 │        │         │                   │
 ◀━━━━━━▶◀━━━━━━━━▶◀━━━━━━━━━━━━━━━━━▶◀━━━━━━━▶
  0~5초    5~10초     10~30초            30초 초과

 추가 규칙: TTC = None (충돌 예상 없음) → NORMAL

 구체적 예시:

 TTC = 3초   →  ●
 0───●──┼────┼────┼────┼────┼────
 │ DANGER │
 └───→ 결과: DANGER (위험) -- 3초 후 충돌!

 TTC = 8초   →        ●
 0───┼──┼────●───┼────┼────┼────
         │WARNING│
         └───→ 결과: WARNING (경고)

 TTC = 25초  →                         ●
 0───┼──┼────┼───┼────┼────●────┼────
                  │   CAUTION   │
                  └───→ 결과: CAUTION (주의)

 TTC = None  → 충돌 예상 없음 → NORMAL (정상)
```

### 4.5 해당 소스 코드

```python
# core/collision.py, 406~414행
ttc = result.time_to_collision   # time to collision

# 시간 기반 등급 판정 (예상 충돌 시간이 있는 경우)
time_level = LEVEL_NORMAL                                          # 기본값: 정상
if ttc is not None:                                                # 충돌 예상이 있을 때만
    if ttc <= ALERT_THRESHOLDS["DANGER"]["time_to_collision"]:     # <= 5초
        time_level = LEVEL_DANGER
    elif ttc <= ALERT_THRESHOLDS["WARNING"]["time_to_collision"]:  # <= 10초
        time_level = LEVEL_WARNING
    elif ttc <= ALERT_THRESHOLDS["CAUTION"]["time_to_collision"]:  # <= 30초
        time_level = LEVEL_CAUTION
# ttc가 None이거나 30초 초과이면 LEVEL_NORMAL 유지
```

### 4.6 왜 `None`을 따로 처리하는가?

```
 ttc = None의 의미:

 (1) 두 크레인 모두 정지해 있는 경우
     → 3단계(궤적 예측) 자체를 수행하지 않음
     → time_to_collision이 초기값 None 그대로 유지

 (2) 크레인이 움직이지만, 서로 멀어지는 방향인 경우
     → 예측 기간(30초) 동안 안전 여유 거리(2m) 이하로
        접근하는 시점이 없음
     → time_to_collision = None

 어느 경우든 "충돌 위험이 없다"는 의미이므로 NORMAL로 판정합니다.
```

---

## 5. "둘 중 더 위험한 쪽" 규칙

거리 기반 등급(`distance_level`)과 시간 기반 등급(`time_level`)을 각각 구한 뒤,
**더 위험한 쪽을 최종 등급으로 채택**합니다.

### 5.1 왜 "더 위험한 쪽"을 선택하는가?

```
 상황을 생각해 봅시다:

 [상황 1] 현재 거리는 7m(주의)이지만, 8초 후 충돌 예상(경고)
  → 지금은 조금 여유가 있지만 빠르게 다가오고 있음
  → 안전을 위해 "경고"를 선택해야 함

 [상황 2] 현재 거리가 2m(위험)이지만, 정지해 있어서 TTC=None(정상)
  → 움직이지 않더라도 2m는 위험한 거리
  → 안전을 위해 "위험"을 선택해야 함

 [결론] 두 기준 중 하나라도 위험하면, 그 위험 수준을 따라야 합니다.
        항상 "안전 우선(보수적 판단)" 원칙입니다.
```

### 5.2 판정 공식

```
 최종 등급 = max(거리 기반 등급, 시간 기반 등급)

 여기서 max는 "더 위험한 쪽"을 의미합니다.
 위험도 순서: NORMAL(0) < CAUTION(1) < WARNING(2) < DANGER(3)
```

### 5.3 구체적인 예시 3가지

#### 예시 1: 거리 7m (CAUTION) + TTC 8초 (WARNING) = WARNING

```
 ┌──────────────────────────────────────────────────┐
 │  현재 거리: 7.0m                                 │
 │  ├── 기준: 5m < 7.0m <= 10m                      │
 │  └── 거리 기반 등급: CAUTION (우선순위 1)         │
 │                                                  │
 │  충돌 예상 시간: 8.0초                           │
 │  ├── 기준: 5초 < 8.0초 <= 10초                   │
 │  └── 시간 기반 등급: WARNING (우선순위 2)         │
 │                                                  │
 │  비교: CAUTION(1) vs WARNING(2)                  │
 │  → WARNING(2)이 더 큼                            │
 │                                                  │
 │  ★ 최종 결과: WARNING (경고)                     │
 └──────────────────────────────────────────────────┘

 해석: 현재 거리는 7m로 여유가 있지만,
       8초 후에 충돌이 예상되므로 더 위험한 WARNING을 채택.
       → 운전자에게 속도를 줄이라고 경고합니다.
```

#### 예시 2: 거리 2m (DANGER) + TTC None (NORMAL) = DANGER

```
 ┌──────────────────────────────────────────────────┐
 │  현재 거리: 2.0m                                 │
 │  ├── 기준: 2.0m <= 3m                            │
 │  └── 거리 기반 등급: DANGER (우선순위 3)          │
 │                                                  │
 │  충돌 예상 시간: None (정지 중)                   │
 │  └── 시간 기반 등급: NORMAL (우선순위 0)          │
 │                                                  │
 │  비교: DANGER(3) vs NORMAL(0)                    │
 │  → DANGER(3)이 더 큼                             │
 │                                                  │
 │  ★ 최종 결과: DANGER (위험)                      │
 └──────────────────────────────────────────────────┘

 해석: 크레인은 정지해 있지만,
       현재 거리가 2m로 매우 가까우므로 DANGER를 채택.
       → 즉시 비상 정지 필요!
```

#### 예시 3: 거리 15m (NORMAL) + TTC 25초 (CAUTION) = CAUTION

```
 ┌──────────────────────────────────────────────────┐
 │  현재 거리: 15.0m                                │
 │  ├── 기준: 15.0m > 10m                           │
 │  └── 거리 기반 등급: NORMAL (우선순위 0)          │
 │                                                  │
 │  충돌 예상 시간: 25.0초                          │
 │  ├── 기준: 10초 < 25.0초 <= 30초                 │
 │  └── 시간 기반 등급: CAUTION (우선순위 1)         │
 │                                                  │
 │  비교: NORMAL(0) vs CAUTION(1)                   │
 │  → CAUTION(1)이 더 큼                            │
 │                                                  │
 │  ★ 최종 결과: CAUTION (주의)                     │
 └──────────────────────────────────────────────────┘

 해석: 현재 거리는 15m로 안전하지만,
       25초 후에 접근이 예상되므로 미리 CAUTION을 채택.
       → 운전자에게 알림을 보냅니다.
```

### 5.4 모든 조합 표

거리 기반 등급과 시간 기반 등급의 모든 조합에 대한 최종 결과:

```
                          시간 기반 등급
                 NORMAL   CAUTION   WARNING   DANGER
              ┌─────────┬─────────┬─────────┬─────────┐
 거  NORMAL   │ NORMAL  │ CAUTION │ WARNING │ DANGER  │
 리  ─────────┼─────────┼─────────┼─────────┼─────────┤
 기  CAUTION  │ CAUTION │ CAUTION │ WARNING │ DANGER  │
 반  ─────────┼─────────┼─────────┼─────────┼─────────┤
 등  WARNING  │ WARNING │ WARNING │ WARNING │ DANGER  │
 급  ─────────┼─────────┼─────────┼─────────┼─────────┤
     DANGER   │ DANGER  │ DANGER  │ DANGER  │ DANGER  │
              └─────────┴─────────┴─────────┴─────────┘

 규칙: 항상 표의 행(거리)과 열(시간) 중 더 높은 등급이 최종 결과
```

### 5.5 해당 소스 코드

```python
# core/collision.py, 416~420행

# 두 기준 중 더 높은(위험한) 등급 채택
if LEVEL_PRIORITY[distance_level] >= LEVEL_PRIORITY[time_level]:
    return distance_level
else:
    return time_level
```

---

## 6. 등급 우선순위 시스템 (LEVEL_PRIORITY)

### 6.1 정의

등급을 비교하려면 "어느 쪽이 더 위험한가?"를 숫자로 표현해야 합니다.
이를 위해 `LEVEL_PRIORITY` 딕셔너리가 정의되어 있습니다.

```python
# core/collision.py, 58~63행
LEVEL_PRIORITY = {
    LEVEL_NORMAL:  0,   # "NORMAL"  → 0 (가장 안전)
    LEVEL_CAUTION: 1,   # "CAUTION" → 1
    LEVEL_WARNING: 2,   # "WARNING" → 2
    LEVEL_DANGER:  3,   # "DANGER"  → 3 (가장 위험)
}
```

### 6.2 사용 방식

```
 숫자가 클수록 위험합니다:

 0        1          2          3
 NORMAL < CAUTION < WARNING < DANGER
 (안전)   (주의)    (경고)    (위험)

 비교 예시:
   LEVEL_PRIORITY["CAUTION"] = 1
   LEVEL_PRIORITY["WARNING"] = 2

   1 < 2  →  WARNING이 더 위험
```

### 6.3 이 우선순위가 사용되는 곳들

시스템 전체에서 등급을 비교해야 하는 모든 곳에서 이 우선순위를 사용합니다:

| 사용 위치 | 용도 |
|-----------|------|
| `_determine_alert_level()` | 거리/시간 등급 중 더 위험한 쪽 선택 |
| `get_overall_status()` | 전체 현장의 최고 위험 등급 결정 |
| `get_overall_status()` | 각 크레인의 최고 위험 등급 결정 |

```
 사용 패턴 (공통):

 if LEVEL_PRIORITY[등급A] > LEVEL_PRIORITY[등급B]:
     # 등급A가 더 위험하다
 else:
     # 등급B가 더 위험하거나 같다
```

---

## 7. 등급 변화 감지와 이벤트 기록

### 7.1 왜 등급 변화를 추적하는가?

```
 관제실 화면에 이런 이력을 표시하고 싶습니다:

 ┌──────────────────────────────────────────────┐
 │  시간     크레인 쌍         변화              │
 │  ─────────────────────────────────────────── │
 │  14:22    TC-1 ↔ TC-2     정상 → 주의       │
 │  14:23    TC-1 ↔ TC-2     주의 → 경고       │
 │  14:25    TC-1 ↔ TC-2     경고 → 주의       │
 │  14:28    TC-1 ↔ TC-2     주의 → 정상       │
 └──────────────────────────────────────────────┘

 이 이력을 만들려면, 매번 검사할 때마다
 "이전 등급과 현재 등급이 다른가?"를 확인해야 합니다.
```

### 7.2 동작 원리 (_check_level_change)

`_check_level_change()` 함수(`core/collision.py`, 422~456행)는 다음과 같이 동작합니다:

```
 ┌─────────────────────────────────────────────┐
 │  이전 검사 결과 (last_results)에서            │
 │  같은 크레인 쌍의 이전 등급을 찾는다          │
 └──────────────────┬──────────────────────────┘
                    │
                    ▼
 ┌─────────────────────────────────────────────┐
 │  이전 등급과 현재 등급이 다른가?              │
 └──────┬───────────────────────┬──────────────┘
        │ 같다                  │ 다르다
        ▼                       ▼
   아무것도 안 함          이벤트 로그에 기록:
                           - 시각 (timestamp)
                           - 크레인 쌍 (pair)
                           - 이전 등급 (from_level)
                           - 현재 등급 (to_level)
                           - 현재 거리 (distance)
```

### 7.3 이벤트 로그 구조

기록되는 이벤트의 형태:

```python
event = {
    "timestamp": 1700000000.0,       # 유닉스 시각
    "pair": "TC-1↔TC-2",            # 크레인 쌍 식별 문자열
    "crane_a_id": "TC-1",           # 크레인 A의 ID
    "crane_b_id": "TC-2",           # 크레인 B의 ID
    "from_level": "CAUTION",        # 이전 등급
    "to_level": "WARNING",          # 현재(변경된) 등급
    "distance": 4.8,                # 현재 거리 (미터)
}
```

### 7.4 메모리 관리

이벤트가 계속 쌓이면 메모리를 많이 차지합니다. 그래서 최대 **1000개**까지만
보관하고, 초과하면 오래된 것부터 삭제합니다.

```python
# core/collision.py, 454~456행
self.max_event_log_size = 1000

if len(self.event_log) > self.max_event_log_size:
    self.event_log = self.event_log[-self.max_event_log_size:]
    #                               ^^^^^^^^^^^^^^^^^^^^^^^^
    #                               마지막 1000개만 남김 (오래된 것 삭제)
```

```
 이벤트 로그 상태 예시:

 [이벤트1, 이벤트2, ..., 이벤트999, 이벤트1000]
     ↑                                    ↑
   가장 오래됨                        가장 최근

 새로운 이벤트가 추가되면:

 [이벤트2, 이벤트3, ..., 이벤트1000, 이벤트1001]
     ↑                                      ↑
   이벤트1은 삭제됨                     새로 추가됨
```

---

## 8. AlertManager: 결과를 사람이 읽는 메시지로

`CollisionEngine`이 내부적으로 사용하는 충돌 검사 결과(`CollisionCheckResult`)는
숫자와 코드로 되어 있어서 기계에게는 좋지만, 사람에게 바로 보여주기는 어렵습니다.

`AlertManager` 클래스(`core/alert.py`)는 이 결과를 **사람이 이해할 수 있는 경고 메시지**로
변환합니다.

### 8.1 전체 변환 흐름

```
 CollisionCheckResult                    AlertMessage
 (기계가 읽는 데이터)                    (사람이 읽는 메시지)

 ┌─────────────────────┐     변환     ┌──────────────────────────────┐
 │ crane_a_id: "TC-1"  │  ────────▶  │ message: "1호기 ↔ 2호기:    │
 │ crane_b_id: "TC-2"  │             │   거리 4.2m - 8초 후         │
 │ alert_level: WARNING│             │   접근 예상 (경고)"          │
 │ current_distance: 4.2│            │                              │
 │ time_to_collision: 8 │            │ voice_text: "경고. 2호기     │
 └─────────────────────┘             │   접근 중. 8초 후 충돌 예상. │
                                     │   거리 4미터."               │
                                     │                              │
                                     │ color: "#FF8C00"             │
                                     └──────────────────────────────┘
```

### 8.2 등급별 메시지 형식

`_create_alert()` 함수(`core/alert.py`, 139~195행)는 등급에 따라 다른 형식의
메시지를 생성합니다.

#### DANGER (위험)

```
 화면 메시지:
 "{이름A} ↔ {이름B}: 거리 {거리}m - 즉시 정지 필요! (위험)"

 예시:
 "1호기 ↔ 2호기: 거리 2.1m - 즉시 정지 필요! (위험)"

 음성(TTS):
 "위험! {이름A}와 {이름B} 충돌 위험. 즉시 정지하세요. 거리 {거리}미터."

 예시:
 "위험! 1호기와 2호기 충돌 위험. 즉시 정지하세요. 거리 2미터."
```

#### WARNING (경고)

```
 [TTC가 있는 경우]
 화면 메시지:
 "{이름A} ↔ {이름B}: 거리 {거리}m - {TTC}초 후 접근 예상 (경고)"

 예시:
 "1호기 ↔ 2호기: 거리 4.2m - 8초 후 접근 예상 (경고)"

 음성(TTS):
 "경고. {이름B} 접근 중. {TTC}초 후 충돌 예상. 거리 {거리}미터."

 예시:
 "경고. 2호기 접근 중. 8초 후 충돌 예상. 거리 4미터."

 ──────────────────────────────────────────────────────

 [TTC가 없는 경우 (정지 상태에서 거리만으로 경고)]
 화면 메시지:
 "{이름A} ↔ {이름B}: 거리 {거리}m (경고)"

 예시:
 "1호기 ↔ 2호기: 거리 4.5m (경고)"

 음성(TTS):
 "경고. {이름B} 방향 주의. 거리 {거리}미터."
```

#### CAUTION (주의)

```
 [TTC가 있는 경우]
 화면 메시지:
 "{이름A} ↔ {이름B}: 거리 {거리}m - {TTC}초 후 접근 예상 (주의)"

 예시:
 "1호기 ↔ 2호기: 거리 8.5m - 25초 후 접근 예상 (주의)"

 음성(TTS):
 "{이름B} 방향 주의. 거리 {거리}미터."

 ──────────────────────────────────────────────────────

 [TTC가 없는 경우]
 화면 메시지:
 "{이름A} ↔ {이름B}: 거리 {거리}m (주의)"

 예시:
 "1호기 ↔ 2호기: 거리 8.5m (주의)"

 음성(TTS):
 "{이름B} 방향 주의. 거리 {거리}미터."
```

#### NORMAL (정상)

```
 NORMAL 등급은 경고 메시지를 생성하지 않습니다.
 process_results()에서 NORMAL은 건너뜁니다:

 if result.alert_level != LEVEL_NORMAL:
     alert = self._create_alert(result)   # NORMAL이 아닌 것만 변환
```

### 8.3 메시지 형식 요약 표

| 등급 | 화면 메시지 패턴 | 음성 안내 패턴 |
|------|-----------------|---------------|
| DANGER | `{A} ↔ {B}: 거리 Xm - 즉시 정지 필요! (위험)` | `위험! {A}와 {B} 충돌 위험. 즉시 정지하세요. 거리 X미터.` |
| WARNING (TTC 있음) | `{A} ↔ {B}: 거리 Xm - N초 후 접근 예상 (경고)` | `경고. {B} 접근 중. N초 후 충돌 예상. 거리 X미터.` |
| WARNING (TTC 없음) | `{A} ↔ {B}: 거리 Xm (경고)` | `경고. {B} 방향 주의. 거리 X미터.` |
| CAUTION (TTC 있음) | `{A} ↔ {B}: 거리 Xm - N초 후 접근 예상 (주의)` | `{B} 방향 주의. 거리 X미터.` |
| CAUTION (TTC 없음) | `{A} ↔ {B}: 거리 Xm (주의)` | `{B} 방향 주의. 거리 X미터.` |
| NORMAL | (메시지 생성 안 함) | (음성 안내 없음) |

### 8.4 음성 텍스트(TTS) 설계 원칙

```
 음성 안내 텍스트는 다음 원칙으로 설계되었습니다:

 (1) 짧고 명확하게
     ├── 운전실은 시끄러움 → 짧은 문장이 잘 들림
     └── 긴 문장은 중간에 끊길 수 있음

 (2) 등급이 높을수록 긴급한 어조
     ├── CAUTION: "{B} 방향 주의."              (담담한 안내)
     ├── WARNING: "경고. {B} 접근 중."          (경고 어조)
     └── DANGER:  "위험! 즉시 정지하세요."       (긴급 어조)

 (3) 핵심 정보만 포함
     ├── 어느 크레인인지 (이름)
     ├── 현재 거리 (미터, 소수점 없이)
     └── 충돌 예상 시간 (해당하는 경우)
```

### 8.5 크레인별 경고 필터링 (get_alerts_for_crane)

실제 현장에서는 각 크레인 운전실에 해당 크레인과 관련된 경고만 보여줘야 합니다.

```
 전체 경고 목록:
 ┌────────────────────────────────────────────┐
 │  1호기 ↔ 2호기: 거리 4.2m (경고)          │  ← TC-1, TC-2 관련
 │  1호기 ↔ 3호기: 거리 8.5m (주의)          │  ← TC-1, TC-3 관련
 │  2호기 ↔ 3호기: 거리 6.1m (주의)          │  ← TC-2, TC-3 관련
 └────────────────────────────────────────────┘

 TC-1 운전실에 보여줄 경고만 필터링:
 get_alerts_for_crane("TC-1", alerts)
 ┌────────────────────────────────────────────┐
 │  1호기 ↔ 2호기: 거리 4.2m (경고)          │  ← TC-1 포함
 │  1호기 ↔ 3호기: 거리 8.5m (주의)          │  ← TC-1 포함
 └────────────────────────────────────────────┘
 (2호기 ↔ 3호기 경고는 TC-1과 무관하므로 제외)

 TC-2 운전실에 보여줄 경고만 필터링:
 get_alerts_for_crane("TC-2", alerts)
 ┌────────────────────────────────────────────┐
 │  1호기 ↔ 2호기: 거리 4.2m (경고)          │  ← TC-2 포함
 │  2호기 ↔ 3호기: 거리 6.1m (주의)          │  ← TC-2 포함
 └────────────────────────────────────────────┘
```

해당 소스 코드 (`core/alert.py`, 228~248행):

```python
def get_alerts_for_crane(
    self, crane_id: str, alerts: List[AlertMessage]
) -> List[AlertMessage]:
    return [
        alert for alert in alerts
        if alert.crane_a_id == crane_id or alert.crane_b_id == crane_id
    ]
```

---

## 9. 크레인별 종합 등급 계산 (get_overall_status)

### 9.1 문제 상황

한 크레인이 여러 다른 크레인과의 관계에서 각각 다른 등급을 받을 수 있습니다.

```
 예시: 크레인 3대 (TC-1, TC-2, TC-3)

 TC-1 ↔ TC-2: WARNING (경고)
 TC-1 ↔ TC-3: CAUTION (주의)
 TC-2 ↔ TC-3: NORMAL  (정상)

 TC-1의 종합 등급은?
  → TC-2와의 관계: WARNING
  → TC-3와의 관계: CAUTION
  → 더 위험한 쪽: WARNING ← 이것이 TC-1의 종합 등급
```

### 9.2 계산 방법

`get_overall_status()` 함수(`core/collision.py`, 458~505행)에서 크레인별 종합 등급을
계산합니다.

```
 알고리즘:

 1. 모든 크레인의 초기 등급을 NORMAL(0)로 설정
 2. 모든 충돌 검사 결과를 순회하며:
    - 결과의 양쪽 크레인에 대해
    - 결과의 등급이 현재 저장된 등급보다 높으면 갱신

 코드로 보면:

 # 1단계: 모든 크레인을 NORMAL로 초기화
 crane_alerts = {}
 for crane_id in self.cranes:
     crane_alerts[crane_id] = LEVEL_NORMAL

 # 2단계: 각 검사 결과를 순회하며 최대 등급 갱신
 for result in self.last_results:
     for cid in [result.crane_a_id, result.crane_b_id]:
         if LEVEL_PRIORITY[result.alert_level] > LEVEL_PRIORITY[crane_alerts[cid]]:
             crane_alerts[cid] = result.alert_level
```

### 9.3 구체적 예시

```
 크레인 4대: TC-1, TC-2, TC-3, TC-4

 충돌 검사 결과:
 ┌──────────────────┬──────────┐
 │ 크레인 쌍        │ 등급     │
 ├──────────────────┼──────────┤
 │ TC-1 ↔ TC-2     │ WARNING  │
 │ TC-1 ↔ TC-3     │ CAUTION  │
 │ TC-1 ↔ TC-4     │ NORMAL   │
 │ TC-2 ↔ TC-3     │ NORMAL   │
 │ TC-2 ↔ TC-4     │ DANGER   │
 │ TC-3 ↔ TC-4     │ CAUTION  │
 └──────────────────┴──────────┘

 계산 과정:

 TC-1: [WARNING(TC-2), CAUTION(TC-3), NORMAL(TC-4)] → max = WARNING
 TC-2: [WARNING(TC-1), NORMAL(TC-3), DANGER(TC-4)]  → max = DANGER
 TC-3: [CAUTION(TC-1), NORMAL(TC-2), CAUTION(TC-4)] → max = CAUTION
 TC-4: [NORMAL(TC-1), DANGER(TC-2), CAUTION(TC-3)]  → max = DANGER

 결과:
 ┌──────────┬──────────┐
 │ 크레인   │ 종합 등급│
 ├──────────┼──────────┤
 │ TC-1     │ WARNING  │
 │ TC-2     │ DANGER   │
 │ TC-3     │ CAUTION  │
 │ TC-4     │ DANGER   │
 └──────────┴──────────┘

 전체 현장 최고 등급: DANGER
```

### 9.4 전체 현장 상태 요약

`get_overall_status()`는 크레인별 등급 외에도 다양한 요약 정보를 반환합니다:

```python
{
    "total_cranes": 4,          # 등록된 전체 크레인 수
    "active_cranes": 4,         # 현재 가동 중인 크레인 수
    "total_pairs": 6,           # 검사한 크레인 쌍 수
    "status_counts": {          # 등급별 쌍 수
        "NORMAL": 2,
        "CAUTION": 2,
        "WARNING": 1,
        "DANGER": 1,
    },
    "highest_alert": "DANGER",  # 전체 현장 최고 위험 등급
    "crane_alerts": {           # 크레인별 종합 등급
        "TC-1": "WARNING",
        "TC-2": "DANGER",
        "TC-3": "CAUTION",
        "TC-4": "DANGER",
    },
    "recent_events": [...],     # 최근 등급 변화 이벤트 20개
}
```

---

## 10. 전체 판정 흐름도

지금까지 설명한 모든 내용을 하나의 흐름도로 정리합니다.

```
 ┌─────────────────────────────────────────────────────────────────────────┐
 │                    크레인 충돌 예측 시스템 - 전체 판정 흐름               │
 └─────────────────────────────────────────────────────────────────────────┘

 시작: 활성 크레인 목록 [TC-1, TC-2, TC-3]
                    │
                    ▼
 ┌─────────────────────────────────────┐
 │ 모든 크레인 쌍 생성                  │
 │ (TC-1,TC-2), (TC-1,TC-3), (TC-2,TC-3)│
 └──────────────────┬──────────────────┘
                    │
        ┌───────────┴───────────┐
        ▼                       ▼
  각 쌍에 대해              (반복)
  _check_pair() 호출
        │
        ▼
 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 ┃  _check_pair(crane_a, crane_b)                                     ┃
 ┃                                                                     ┃
 ┃  ┌───────────────────────────────────────────────┐                  ┃
 ┃  │ [1단계] 작업 반경 중첩 확인                    │                  ┃
 ┃  │ check_working_radius_overlap()                │                  ┃
 ┃  └───────────────────┬───────────────────────────┘                  ┃
 ┃                      │                                              ┃
 ┃            ┌─────────┴─────────┐                                    ┃
 ┃            │ 중첩 있음?        │                                    ┃
 ┃            └──┬─────────────┬──┘                                    ┃
 ┃          아니오│            │예                                     ┃
 ┃               ▼             ▼                                       ┃
 ┃        ┌──────────┐  ┌───────────────────────────────────┐         ┃
 ┃        │  NORMAL  │  │ [2단계] 현재 거리 측정             │         ┃
 ┃        │  반환    │  │ - boom_tip_distance                │         ┃
 ┃        └──────────┘  │ - current_distance (선분 간)       │         ┃
 ┃                       └─────────────────┬─────────────────┘         ┃
 ┃                                         │                           ┃
 ┃                                         ▼                           ┃
 ┃                       ┌─────────────────────────────────────┐       ┃
 ┃                       │ 크레인이 움직이고 있는가?            │       ┃
 ┃                       │ (slew_speed > 0.01 또는              │       ┃
 ┃                       │  luffing_speed > 0.01)               │       ┃
 ┃                       └──────┬─────────────────────┬────────┘       ┃
 ┃                        아니오│                     │예              ┃
 ┃                              │                     ▼                ┃
 ┃                              │   ┌──────────────────────────────┐   ┃
 ┃                              │   │ [3단계] 미래 궤적 예측        │   ┃
 ┃                              │   │ _predict_collision()          │   ┃
 ┃                              │   │                              │   ┃
 ┃                              │   │ 0.5초 간격, 30초 앞까지      │   ┃
 ┃                              │   │ → time_to_collision (TTC)    │   ┃
 ┃                              │   │ → min_predicted_distance     │   ┃
 ┃                              │   └──────────────┬───────────────┘   ┃
 ┃                              │                  │                   ┃
 ┃                              ▼                  ▼                   ┃
 ┃                       ┌─────────────────────────────────────┐       ┃
 ┃                       │ [4단계] 위험 등급 판정               │       ┃
 ┃                       │ _determine_alert_level()             │       ┃
 ┃                       └─────────────────┬───────────────────┘       ┃
 ┃                                         │                           ┃
 ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━┛
                                           │
 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━
 ┃  _determine_alert_level(result)          │                           ┃
 ┃                                          ▼                           ┃
 ┃            ┌──────────────────────────────────────────┐              ┃
 ┃            │         거리 기반 등급 판정               │              ┃
 ┃            │                                          │              ┃
 ┃            │  distance <= 3.0m  → DANGER   (위험)     │              ┃
 ┃            │  distance <= 5.0m  → WARNING  (경고)     │              ┃
 ┃            │  distance <= 10.0m → CAUTION  (주의)     │              ┃
 ┃            │  distance > 10.0m  → NORMAL   (정상)     │              ┃
 ┃            │                                          │              ┃
 ┃            │  결과: distance_level                     │              ┃
 ┃            └──────────────────────┬───────────────────┘              ┃
 ┃                                   │                                  ┃
 ┃                                   ▼                                  ┃
 ┃            ┌──────────────────────────────────────────┐              ┃
 ┃            │         시간 기반 등급 판정               │              ┃
 ┃            │                                          │              ┃
 ┃            │  ttc = None        → NORMAL   (정상)     │              ┃
 ┃            │  ttc <= 5.0초      → DANGER   (위험)     │              ┃
 ┃            │  ttc <= 10.0초     → WARNING  (경고)     │              ┃
 ┃            │  ttc <= 30.0초     → CAUTION  (주의)     │              ┃
 ┃            │  ttc > 30.0초      → NORMAL   (정상)     │              ┃
 ┃            │                                          │              ┃
 ┃            │  결과: time_level                         │              ┃
 ┃            └──────────────────────┬───────────────────┘              ┃
 ┃                                   │                                  ┃
 ┃                                   ▼                                  ┃
 ┃            ┌──────────────────────────────────────────┐              ┃
 ┃            │       두 등급 중 더 위험한 쪽 선택        │              ┃
 ┃            │                                          │              ┃
 ┃            │  LEVEL_PRIORITY[distance_level]           │              ┃
 ┃            │           vs                             │              ┃
 ┃            │  LEVEL_PRIORITY[time_level]               │              ┃
 ┃            │                                          │              ┃
 ┃            │  → max(distance_level, time_level)        │              ┃
 ┃            └──────────────────────┬───────────────────┘              ┃
 ┃                                   │                                  ┃
 ┃                              최종 등급 반환                          ┃
 ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
                                     │
                                     ▼
                    ┌────────────────────────────────────┐
                    │ CollisionCheckResult 완성           │
                    │ (alert_level 포함)                  │
                    └─────────────────┬──────────────────┘
                                     │
                                     ▼
                    ┌────────────────────────────────────┐
                    │ _check_level_change()               │
                    │ 이전 등급과 비교 → 변화 시 로그 기록│
                    └─────────────────┬──────────────────┘
                                     │
                                     ▼
                    ┌────────────────────────────────────┐
                    │ AlertManager.process_results()      │
                    │ NORMAL 이외 → 경고 메시지 생성      │
                    └─────────────────┬──────────────────┘
                                     │
                    ┌─────────────────┴──────────────────┐
                    │                                    │
                    ▼                                    ▼
     ┌──────────────────────┐          ┌──────────────────────────┐
     │ 화면 메시지 (message) │          │ 음성 안내 (voice_text)    │
     │ 색상 (color)          │          │ TTS 엔진에서 음성 출력    │
     │ 관제 화면에 표시      │          │ 운전실 스피커로 전달      │
     └──────────────────────┘          └──────────────────────────┘
```

---

## 부록: 기준값 일람표

시스템에서 사용하는 모든 기준값을 한눈에 정리합니다.
이 값들은 `config/settings.py`에서 변경할 수 있습니다.

### A. 경보 기준값

| 등급 | 거리 기준 | 시간 기준 | 색상 | 대응 행동 |
|------|-----------|-----------|------|-----------|
| DANGER | <= 3.0m | <= 5.0초 | #FF0000 (빨강) | 비상 정지 |
| WARNING | <= 5.0m | <= 10.0초 | #FF8C00 (주황) | 속도 제한 |
| CAUTION | <= 10.0m | <= 30.0초 | #FFD700 (노랑) | 운전자 알림 |
| NORMAL | > 10.0m | > 30.0초 또는 None | #00CC00 (초록) | 정상 운행 |

### B. 예측 관련 설정값

| 설정 항목 | 값 | 설명 |
|-----------|-----|------|
| PREDICTION_TIME_SECONDS | 30.0초 | 미래 예측 시간 범위 |
| PREDICTION_STEP_SECONDS | 0.5초 | 예측 계산 간격 |
| SAFETY_MARGIN_METERS | 2.0m | 충돌 판정 안전 여유 거리 |

### C. 등급 우선순위

| 등급 | 우선순위 숫자 |
|------|--------------|
| NORMAL | 0 (가장 안전) |
| CAUTION | 1 |
| WARNING | 2 |
| DANGER | 3 (가장 위험) |

---

## 부록: 용어 정리

| 용어 | 영문 | 의미 |
|------|------|------|
| 위험등급 | Alert Level | 크레인 간 충돌 위험의 심각도를 나타내는 4단계 분류 |
| 거리 기반 등급 | Distance Level | 현재 붐대 간 최소 거리를 기준으로 판정한 등급 |
| 시간 기반 등급 | Time Level | 예상 충돌 시간(TTC)을 기준으로 판정한 등급 |
| TTC | Time To Collision | 현재 속도 유지 시 충돌까지 남은 예상 시간 (초) |
| 작업 반경 | Working Radius | 크레인 붐대가 회전할 수 있는 최대 원형 범위 |
| 붐대 끝점 | Boom Tip | 크레인 팔(붐)의 맨 끝 지점 |
| 선분 간 거리 | Segment Distance | 두 직선 구간 사이의 가장 가까운 거리 |
| 이벤트 로그 | Event Log | 등급 변화가 발생할 때마다 기록하는 이력 |
| 안전 여유 거리 | Safety Margin | 이 거리 이하로 접근하면 충돌 가능성으로 판단하는 기준 (2.0m) |

---

## 부록: 관련 소스 파일

| 파일 경로 | 주요 내용 | 관련 장 |
|-----------|----------|---------|
| `config/settings.py` | ALERT_THRESHOLDS, ALERT_COLORS 등 기준값 정의 | 3, 4장 |
| `core/collision.py` (52~63행) | LEVEL_* 상수, LEVEL_PRIORITY 정의 | 1, 6장 |
| `core/collision.py` (201~305행) | `_check_pair()` - 4단계 검사 파이프라인 | 2장 |
| `core/collision.py` (378~420행) | `_determine_alert_level()` - 등급 판정 로직 | 3, 4, 5장 |
| `core/collision.py` (422~456행) | `_check_level_change()` - 등급 변화 감지 | 7장 |
| `core/collision.py` (458~505행) | `get_overall_status()` - 종합 상태 계산 | 9장 |
| `core/alert.py` (83~248행) | `AlertManager` 클래스 - 메시지 변환 | 8장 |
