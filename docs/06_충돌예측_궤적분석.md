# 충돌 예측 - 미래 궤적 분석

> 이 문서는 `core/geometry.py`의 `predict_future_position()`과
> `core/collision.py`의 `_predict_collision()` 함수를 설명합니다.
> "현재 속도로 계속 움직이면 미래에 충돌하는가?"를 계산하는 핵심 로직입니다.

---

## 왜 미래 예측이 필요한가?

**현재** 거리가 50m로 안전해도, 두 크레인이 서로를 향해 **움직이고 있다면** 곧 위험해질 수 있습니다.

```
현재 (안전)                    10초 후 (위험!)

   A●───→                        ●A─→
                                  ↕ 3m
   ←───●B                     ←─●B

  거리 = 50m                   거리 = 3m!
```

미리 예측하면 **"10초 후 충돌 예상!"** 같은 사전 경고가 가능합니다.

---

## 핵심 아이디어: 등속 운동 가정

**등속 운동** = "현재 속도가 변하지 않고 계속 유지된다"는 가정

```
미래 위치 = 현재 위치 + 속도 × 시간
```

이것은 자동차 운전과 같습니다:
- 현재 시속 60km로 달리고 있다면
- 1시간 후에 60km 앞에 있을 것이다
- 2시간 후에 120km 앞에 있을 것이다

크레인에서는 **각도**가 변합니다:
```
미래 선회각 = 현재 선회각 + (선회 속도 × 시간)
미래 기복각 = 현재 기복각 + (기복 속도 × 시간)
```

---

## 미래 위치 계산 (predict_future_position)

### 계산 과정

```
[입력]
현재 선회각: 30도
선회 속도: 2도/초
예측 시간: 5초

[계산]
미래 선회각 = 30 + (2 × 5) = 40도

[출력]
미래 선회각 40도일 때의 붐대 끝점 좌표
→ calculate_boom_tip_position(..., slew_angle=40, ...) 호출
```

### 실제 숫자 예시

**1호기 조건**:
- 기초: (0, 0), 마스트: 40m, 붐대: 60m
- 현재 선회각: 30도
- 선회 속도: 2도/초 (시계방향)
- 기복각: 15도 (변화 없음)

**5초 후 예측**:
```
미래 선회각 = 30 + (2 × 5) = 40도
미래 기복각 = 15 + (0 × 5) = 15도 (변화 없음)

수평 거리 = 60 × cos(15도) = 57.96m
X = 0 + 57.96 × sin(40도) = 57.96 × 0.643 = 37.26m
Y = 0 + 57.96 × cos(40도) = 57.96 × 0.766 = 44.40m
Z = 40 + 60 × sin(15도) = 55.53m

5초 후 1호기 끝점: (37.26, 44.40, 55.53)
```

**10초 후 예측**:
```
미래 선회각 = 30 + (2 × 10) = 50도

X = 0 + 57.96 × sin(50도) = 57.96 × 0.766 = 44.40m
Y = 0 + 57.96 × cos(50도) = 57.96 × 0.643 = 37.26m
Z = 55.53m (변화 없음)

10초 후 1호기 끝점: (44.40, 37.26, 55.53)
```

**코드** (`core/geometry.py:232-246`):
```python
def predict_future_position(..., time_seconds):
    # 미래 각도 계산
    future_slew = current_slew_deg + slew_speed_deg_per_sec * time_seconds
    future_luffing = current_luffing_deg + luffing_speed_deg_per_sec * time_seconds

    # 기복각 범위 제한 (0~80도)
    future_luffing = max(0.0, min(80.0, future_luffing))

    # 선회각 정규화 (0~360도)
    future_slew = future_slew % 360.0

    return calculate_boom_tip_position(
        base_x, base_y, mast_height, boom_length,
        future_slew, future_luffing,
    )
```

---

## 범위 제한이 필요한 이유

### 기복각 제한 (0도 ~ 80도)

실제 크레인은 붐대를 90도(완전 수직) 이상 올릴 수 없습니다. 물리적 한계가 있습니다.

```
기복 속도 5도/초, 현재 기복각 70도, 100초 후?

단순 계산: 70 + 5 × 100 = 570도 ← 말이 안 됨!
범위 제한: max(0, min(80, 570)) = 80도 ← 실제 한계
```

### 선회각 정규화 (0도 ~ 360도)

선회각이 360도를 넘으면 한 바퀴를 돈 것이므로 다시 0도부터 시작합니다.

```
현재 350도에서 2도/초로 10초 후?

단순 계산: 350 + 20 = 370도
정규화: 370 % 360 = 10도 ← 한 바퀴 돌고 10도 위치
```

> `%` 연산자는 **나머지**를 구합니다. 370 ÷ 360 = 1 나머지 10.

---

## 충돌 예측 (_predict_collision)

미래 위치를 계산하는 것은 한 크레인에 대한 것이고, 실제 충돌 예측은 **두 크레인의 미래 위치를 동시에 계산**해서 거리를 비교합니다.

### 동작 원리

```
시간:  0.5초  1.0초  1.5초  2.0초  2.5초 ... 29.5초  30.0초
       │      │      │      │      │          │       │
       ▼      ▼      ▼      ▼      ▼          ▼       ▼
A위치: 계산   계산   계산   계산   계산   ...  계산    계산
B위치: 계산   계산   계산   계산   계산   ...  계산    계산
       │      │      │      │      │          │       │
       ▼      ▼      ▼      ▼      ▼          ▼       ▼
거리:  45m    38m    32m    28m    25m   ...  50m     55m
                                    ↑
                           최소 거리 시점
```

0.5초 간격으로 30초 후까지 = **60개 시점**을 검사합니다.

### 무엇을 찾는가?

1. **최소 접근 거리**: 60개 시점 중 가장 가까워지는 시점의 거리
2. **최소 접근 시점**: 그때가 몇 초 후인지
3. **충돌 예상 시간**: 거리가 안전 여유(2m) 이내로 들어오는 **첫 번째** 시점

### 숫자로 보는 전체 예시

**조건**:
- 1호기: 기초(0,0), 선회각 30도, 선회속도 +1도/초 (시계방향)
- 2호기: 기초(80,0), 선회각 210도, 선회속도 -1도/초 (반시계방향)
- 둘 다 서로를 향해 회전 중

```
시점 │ 1호기 선회각 │ 2호기 선회각 │ 끝점 거리 │ 비고
─────┼────────────┼────────────┼──────────┼──────
0.5초│ 30.5도     │ 209.5도    │ 92.1m    │ 안전
1.0초│ 31.0도     │ 209.0도    │ 91.8m    │ 안전
...  │            │            │          │
10초 │ 40.0도     │ 200.0도    │ 82.3m    │ 안전
...  │            │            │          │
20초 │ 50.0도     │ 190.0도    │ 64.5m    │ 안전
...  │            │            │          │
25초 │ 55.0도     │ 185.0도    │ 41.2m    │ 안전
...  │            │            │          │
30초 │ 60.0도     │ 180.0도    │ 22.8m    │ 안전
```

이 경우 30초 이내에 안전 여유(2m) 이내 접근이 없으므로:
- `time_to_collision = None` (충돌 예상 없음)
- `min_distance = 22.8m` (최소 접근 거리)
- `min_distance_time = 30.0초` (최소 접근 시점)

### 위험한 경우 예시

**조건**: 두 크레인이 아주 가까이(70m 거리) 설치되어 서로를 향해 빠르게 회전

```
시점 │ 끝점 거리 │ 비고
─────┼──────────┼──────
0.5초│ 25.3m    │ 안전
2.0초│ 18.7m    │ 안전
4.0초│ 12.1m    │ 주의 (10m 이내)
6.0초│  6.5m    │ 경고 (5m 이내)
7.5초│  3.2m    │ 경고
8.0초│  1.8m    │ ← 2m 이내 진입! time_to_collision = 8.0초
8.5초│  1.2m    │ 위험
9.0초│  2.5m    │ (지나침)
10초 │  5.1m    │
```

결과:
- `time_to_collision = 8.0초` (8초 후 충돌 예상)
- `min_distance = 1.2m` (최소 접근 거리)
- `min_distance_time = 8.5초` (최소 접근 시점)

---

## 코드 흐름

**`_predict_collision()` 함수** (`core/collision.py:307-376`):

```
초기화:
  min_distance = 무한대
  time_to_collision = None

t = 0.5초부터 30초까지 0.5초 간격:
  │
  ├─ 1호기의 t초 후 끝점 좌표 계산
  ├─ 2호기의 t초 후 끝점 좌표 계산
  ├─ 두 끝점 사이 거리 계산
  │
  ├─ 이 거리가 지금까지 최소인가?
  │    예 → min_distance 갱신, min_distance_time = t
  │
  └─ 이 거리가 안전여유(2m) 이하인가?
       예 (처음) → time_to_collision = t

결과 반환:
  {time_to_collision, min_distance, min_distance_time}
```

---

## 설정값 (config/settings.py)

| 설정 | 값 | 코드 변수명 | 의미 |
|------|-----|------------|------|
| 예측 시간 | 30초 | `PREDICTION_TIME_SECONDS` | 몇 초 앞까지 예측할지 |
| 예측 간격 | 0.5초 | `PREDICTION_STEP_SECONDS` | 몇 초 단위로 검사할지 |
| 안전 여유 | 2.0m | `SAFETY_MARGIN_METERS` | 충돌 판정 기준 거리 |

### 검사 횟수

```
검사 횟수 = 예측 시간 ÷ 예측 간격 = 30 ÷ 0.5 = 60회

각 검사마다:
  - 1호기 미래 위치 계산 (삼각함수 3~4회)
  - 2호기 미래 위치 계산 (삼각함수 3~4회)
  - 거리 계산 (제곱근 1회)

총 계산량: 약 60 × 10 = 600회 연산
→ 컴퓨터로 1ms 미만 소요 (매우 빠름)
```

---

## 예측의 한계

이 시스템의 예측은 **"현재 속도가 유지된다"**는 가정에 기반합니다.

실제로 운전자가 방향을 바꾸거나 정지하면 예측이 달라집니다. 하지만:

1. **0.1초마다 예측을 다시 계산**하므로 변화에 빠르게 대응합니다
2. 방향이 바뀌면 다음 계산에서 즉시 새 예측이 나옵니다
3. 최악의 경우(아무도 안 멈춤)를 가정하는 것이 안전 측면에서 적절합니다

```
시간 흐름:

t=0초: 예측 "8초 후 충돌" → 경고 발생!
t=2초: 운전자가 감속 → 새 예측 "15초 후 충돌" → 경고 유지
t=4초: 운전자가 방향 전환 → 새 예측 "충돌 없음" → 경고 해제
```
