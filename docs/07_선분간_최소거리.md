# 선분 간 최소 거리 - 붐대 충돌의 정밀 판단

> 이 문서는 두 크레인 붐대(선분) 사이의 **최소 거리**를 구하는 알고리즘을 설명합니다.
> `core/geometry.py`의 `closest_distance_between_segments()` 함수 (285~376행)에 해당합니다.
> **수학을 잘 못하는 분**도 이해할 수 있도록 처음부터 하나씩 설명합니다.

---

## 목차

1. [왜 선분 간 거리가 필요한가?](#1-왜-선분-간-거리가-필요한가)
2. [직선 vs 선분 - 뭐가 다른가?](#2-직선-vs-선분---뭐가-다른가)
3. [매개변수로 선분 위의 점 표현하기](#3-매개변수로-선분-위의-점-표현하기)
4. [벡터란 무엇인가?](#4-벡터란-무엇인가)
5. [내적(dot product)이란?](#5-내적dot-product이란)
6. [알고리즘 단계별 설명](#6-알고리즘-단계별-설명)
7. [특수한 경우(엣지 케이스) 처리](#7-특수한-경우엣지-케이스-처리)
8. [숫자로 따라가는 전체 예제](#8-숫자로-따라가는-전체-예제)
9. [왜 끝점 거리보다 정확한가?](#9-왜-끝점-거리보다-정확한가)
10. [코드 위치 안내](#10-코드-위치-안내)
11. [충돌 검사 시스템에서의 활용](#11-충돌-검사-시스템에서의-활용)

---

## 1. 왜 선분 간 거리가 필요한가?

### 끝점만 보면 안 되는 이유

두 크레인의 충돌 위험을 판단할 때, **붐대 끝점(tip)끼리의 거리**만 보면 위험을 놓칠 수 있습니다.

왜일까요? 붐대는 **긴 막대**이기 때문입니다. 끝점은 멀어도 **중간 부분**이 가까울 수 있습니다!

### 위험한 상황 그림

**상황 1: 끝점만 보면 "안전"하다고 착각하는 경우**

```
위에서 내려다 본 모습:

                     붐대A 끝점
                        ●
                       ╱
                      ╱
                     ╱
    A 마스트 ●──────╱
                   ╲╱  ← 여기! 붐대 중간이 아슬아슬하게 스침!!
                   ╱╲     (불과 2m 차이)
                  ╱  ╲
                 ╱    ╲
    B 마스트   ●       ╲
                        ●
                     붐대B 끝점

    끝점 간 거리: 45m (멀어 보임)
    중간 부분 최소 거리: 2m (실제로는 매우 위험!!)
```

**상황 2: 끝점 거리만으로 충분한 경우**

```
위에서 내려다 본 모습:

    A 마스트 ●────────────● A 끝점
                                          ← 30m →
                                   B 마스트 ●────────────● B 끝점

    이 경우는 끝점이든 중간이든 멀리 있으므로 안전
```

### 핵심 메시지

```
┌─────────────────────────────────────────────────────────┐
│  붐대 = 긴 막대 (60m짜리!)                               │
│                                                          │
│  끝점 거리만 보면:  "45m라 안전!"  → 틀릴 수 있음!        │
│  선분 거리를 보면:  "2m라 위험!"   → 정확한 판단!         │
│                                                          │
│  그래서 붐대 전체를 "선분"으로 보고 최소 거리를 구합니다   │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 직선 vs 선분 - 뭐가 다른가?

수학을 안 좋아하셔도 이건 쉽습니다!

### 직선 (Line)

양쪽으로 **끝없이** 뻗어나가는 선입니다.

```
←────────────────────────────────────────────────────→
     끝이 없음                              끝이 없음
```

### 반직선 (Ray)

한쪽에 시작점이 있고, 다른 쪽으로 **끝없이** 뻗어나갑니다.

```
●────────────────────────────────────────────────────→
시작점                                        끝이 없음
```

### 선분 (Line Segment) -- 우리가 쓰는 것!

시작점과 끝점이 **둘 다 있는** 유한한 선입니다.

```
●──────────────────────────────────●
시작점                              끝점
```

### 크레인에서의 선분

크레인 붐대는 딱 **선분**입니다!

```
    마스트 꼭대기 (시작점)         붐대 끝점 (끝점)
          ●───────────────────────────●
          │                            │
          │    이 사이가 붐대(선분)     │
          │                            │
       s = 0                        s = 1
    (여기서 시작)                (여기서 끝)
```

- **시작점**: 마스트 꼭대기 (붐대가 달린 곳)
- **끝점**: 붐대 끝 (후크/와이어가 달린 곳)
- **길이**: 붐대 길이 (예: 60m)

### 왜 직선이 아니라 선분인가?

```
직선으로 계산하면?

←──────●───────────────────────────●──────────→
       마스트    실제 붐대 영역      끝점
  가상의 영역이                          가상의 영역이
  포함됨 (잘못!)                         포함됨 (잘못!)

→ 실제로 존재하지 않는 부분까지 계산하게 되어 부정확!

선분으로 계산하면?

       ●───────────────────────────●
       마스트    실제 붐대 영역      끝점

→ 실제 붐대 범위만 정확하게 계산! ✓
```

---

## 3. 매개변수로 선분 위의 점 표현하기

### 매개변수란?

"매개변수"라는 말이 어렵게 들리지만, 쉽게 말하면 **"지금 선분의 어디쯤에 있는가"를 0에서 1 사이 숫자로 표현**하는 것입니다.

```
s = 0          s = 0.25        s = 0.5         s = 0.75        s = 1
│               │               │               │               │
▼               ▼               ▼               ▼               ▼
●───────────────┼───────────────┼───────────────┼───────────────●
시작점          1/4 지점         중간점          3/4 지점        끝점
(0%)           (25%)           (50%)           (75%)          (100%)
```

- **s = 0**: 시작점에 있다 (0%를 지남)
- **s = 0.5**: 정중앙에 있다 (50%를 지남)
- **s = 1**: 끝점에 있다 (100%를 지남)
- **s = 0.3**: 시작점에서 30% 지점에 있다

### 수학 공식

선분 위의 아무 점을 이렇게 표현합니다:

```
P(s) = P1 + s × (P2 - P1)

여기서:
  P1 = 시작점
  P2 = 끝점
  s  = 0에서 1 사이의 숫자
```

이 공식을 풀어서 쓰면:

```
P(s) = P1 + s × (P2 - P1)
     = (1-s) × P1 + s × P2       ← 이렇게도 쓸 수 있음

s=0일 때: P(0) = 1×P1 + 0×P2 = P1 (시작점!) ✓
s=1일 때: P(1) = 0×P1 + 1×P2 = P2 (끝점!)   ✓
s=0.5일 때: P(0.5) = 0.5×P1 + 0.5×P2 (정중앙!) ✓
```

### 실제 크레인 숫자로 이해하기

크레인 하나를 예로 들어봅시다.

```
설정값:
  기초 위치: (0, 0)
  마스트 높이: 40m
  붐대 길이: 60m
  선회각: 40°
  기복각: 15°
```

이 크레인의 붐대 선분은:

```
  시작점 P1 = 마스트 꼭대기 = (0, 0, 40)        ← x=0, y=0, 높이=40m
  끝  점 P2 = 붐대 끝점     = (37.26, 44.40, 55.53)  ← 계산된 좌표
```

> 끝점 좌표가 어떻게 나왔는지는 [04_좌표계산_붐대위치.md](04_좌표계산_붐대위치.md)를 참고하세요.

이제 s값에 따라 선분 위의 점을 구해봅시다:

```
P(s) = P1 + s × (P2 - P1)
     = (0, 0, 40) + s × (37.26-0, 44.40-0, 55.53-40)
     = (0, 0, 40) + s × (37.26, 44.40, 15.53)
```

#### s = 0 (시작점 = 마스트 꼭대기)

```
P(0) = (0, 0, 40) + 0 × (37.26, 44.40, 15.53)
     = (0, 0, 40) + (0, 0, 0)
     = (0, 0, 40)  ← 마스트 꼭대기! ✓
```

#### s = 1 (끝점 = 붐대 끝)

```
P(1) = (0, 0, 40) + 1 × (37.26, 44.40, 15.53)
     = (0, 0, 40) + (37.26, 44.40, 15.53)
     = (37.26, 44.40, 55.53)  ← 붐대 끝점! ✓
```

#### s = 0.5 (정확히 중간)

```
P(0.5) = (0, 0, 40) + 0.5 × (37.26, 44.40, 15.53)
       = (0, 0, 40) + (18.63, 22.20, 7.77)
       = (18.63, 22.20, 47.77)  ← 붐대 한가운데!
```

#### 그림으로 정리

```
                                          ● P2 = (37.26, 44.40, 55.53)
                                         ╱   s = 1 (붐대 끝)
                                        ╱
                                       ╱
                          ○ (18.63, 22.20, 47.77)
                         ╱   s = 0.5 (중간)
                        ╱
                       ╱
● P1 = (0, 0, 40)    ╱
  s = 0 (마스트 꼭대기)

    "s는 시작점(0)에서 끝점(1) 사이 어디에 있는지 알려주는 리모컨 같은 것"
```

### 왜 이렇게 표현하나?

```
이점:
  선분 위의 모든 점을 → 숫자 하나(s)로 표현 가능!
  s를 0에서 1까지 바꾸면 → 선분 위를 쭉 훑을 수 있음!

  두 선분에서 각각 s와 t를 조절하면
  "가장 가까운 점 쌍"을 찾을 수 있음!
```

---

## 4. 벡터란 무엇인가?

코드에서 벡터(vector)라는 것이 나옵니다. 어렵지 않습니다!

### 일상에서의 벡터

벡터는 **"방향 + 크기"**를 가진 화살표입니다.

```
"동쪽으로 5m 가세요"  → 이것이 벡터!

  방향: 동쪽
  크기: 5m

  ●────────→
  현재위치    5m 동쪽
```

### 숫자로 표현하기

3D 공간에서 벡터는 **(x, y, z)** 세 숫자로 표현합니다.

```
벡터 (3, 4, 0)의 의미:
  "x방향으로 3, y방향으로 4, z방향으로 0 이동하라"

           ● 도착
          ╱│
         ╱ │ y방향 4
        ╱  │
  출발 ●───┘
       x방향 3
```

### 점과 벡터의 관계

두 점이 있으면, 한 점에서 다른 점으로 가는 벡터를 구할 수 있습니다.

```
점A = (2, 1, 0)
점B = (5, 5, 3)

A에서 B로 가는 벡터 = B - A = (5-2, 5-1, 3-0) = (3, 4, 3)

의미: "A에서 x방향으로 3, y방향으로 4, z방향으로 3 가면 B에 도착"
```

### 크레인에서의 벡터 예시

```
마스트 꼭대기 P1 = (0, 0, 40)
붐대 끝점    P2 = (37.26, 44.40, 55.53)

방향 벡터 d = P2 - P1 = (37.26, 44.40, 15.53)

의미: "마스트 꼭대기에서 x방향으로 37.26m, y방향으로 44.40m,
       위로 15.53m 가면 붐대 끝점에 도착한다"
```

```
                                  ● P2 (37.26, 44.40, 55.53)
                                ╱
                              ╱
            방향 벡터 d     ╱    d = (37.26, 44.40, 15.53)
           ─────────→    ╱
                        ╱
                      ╱
● P1 (0, 0, 40)

  이 화살표가 벡터!
  "마스트에서 붐대 끝까지의 방향과 거리"를 나타냄
```

### 벡터의 크기 (길이)

벡터의 길이는 피타고라스 정리로 구합니다. (3D 확장)

```
벡터 (3, 4, 0)의 길이 = √(3² + 4² + 0²) = √(9+16) = √25 = 5

벡터 d = (37.26, 44.40, 15.53)의 길이
    = √(37.26² + 44.40² + 15.53²)
    = √(1388.31 + 1971.36 + 241.18)
    = √3600.85
    ≈ 60.01m  ← 붐대 길이(60m)와 거의 같음! 당연하죠!
```

---

## 5. 내적(dot product)이란?

코드에서 `_dot()` 함수가 나옵니다. 내적은 두 벡터를 "곱하는" 방법 중 하나입니다.

### 내적의 계산 방법

두 벡터의 같은 위치 성분끼리 곱해서 모두 더합니다.

```
벡터 A = (a1, a2, a3)
벡터 B = (b1, b2, b3)

내적 A·B = a1×b1 + a2×b2 + a3×b3

결과는 숫자 하나! (벡터가 아님!)
```

### 간단한 예시

```
예시 1:
  A = (2, 3, 1)
  B = (4, 1, 5)

  A·B = 2×4 + 3×1 + 1×5
      = 8 + 3 + 5
      = 16

예시 2:
  A = (1, 0, 0)
  B = (0, 1, 0)

  A·B = 1×0 + 0×1 + 0×0
      = 0

예시 3:
  A = (3, 4, 0)
  B = (3, 4, 0)    ← 자기 자신과 내적

  A·A = 3×3 + 4×4 + 0×0
      = 9 + 16
      = 25          ← 이것은 길이의 제곱! (√25 = 5)
```

### 내적이 알려주는 것

내적의 결과는 **두 벡터가 얼마나 같은 방향인지** 알려줍니다.

```
A·B > 0  → 비슷한 방향 (둘이 같은 쪽을 향함)
A·B = 0  → 수직 (직각, 90도)
A·B < 0  → 반대 방향 (둘이 서로 등을 짐)
```

```
    비슷한 방향 (양수)          수직 (0)              반대 방향 (음수)

     A →                       A →                    A →
         → B                   ↑ B                  ← B

    A·B = 큰 양수              A·B = 0              A·B = 큰 음수
```

### 자기 자신과의 내적 = 길이의 제곱

이것은 코드에서 자주 쓰이는 성질입니다.

```
벡터 v = (a, b, c)

v·v = a×a + b×b + c×c = a² + b² + c²

이것은 |v|² (벡터 길이의 제곱)과 같습니다!

예: v = (3, 4, 0)
    v·v = 9 + 16 + 0 = 25
    |v| = √25 = 5
    |v|² = 25 = v·v  ✓
```

### 코드에서의 내적

```python
# core/geometry.py:379-381
def _dot(v1, v2):
    """두 3D 벡터의 내적(dot product)을 계산합니다."""
    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]
    #      ──x끼리 곱──   ──y끼리 곱──   ──z끼리 곱──
    #                    더함          더함
```

---

## 6. 알고리즘 단계별 설명

이제 두 선분 사이의 최소 거리를 구하는 알고리즘을 단계별로 봅시다.

### 전체 흐름 요약

```
입력: 선분1 (P1→P2), 선분2 (P3→P4)
                │
                ▼
        ┌─────────────────┐
        │ 1. 방향 벡터 계산 │   d1, d2, r
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 2. 내적 계산     │   a, b, c, e, f
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 3. 특수 경우 확인 │   선분이 점? 평행?
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 4. 최적 s, t 계산│   가장 가까운 위치 매개변수
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 5. 범위 보정     │   s, t를 0~1로 제한 (클램핑)
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 6. 최소 거리 계산 │   최종 답!
        └─────────────────┘
```

### 단계 1: 방향 벡터 계산

먼저 세 가지 벡터를 구합니다.

```python
# 코드 (320-323행)
d1 = (p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2])  # 선분1의 방향
d2 = (p4[0]-p3[0], p4[1]-p3[1], p4[2]-p3[2])  # 선분2의 방향
r  = (p1[0]-p3[0], p1[1]-p3[1], p1[2]-p3[2])  # 시작점 차이
```

```
d1 = P2 - P1 = 선분1이 어느 방향으로 뻗어있는가

    P1 ●─────────────→ P2
          d1 (방향 벡터)

d2 = P4 - P3 = 선분2가 어느 방향으로 뻗어있는가

    P3 ●─────────────→ P4
          d2 (방향 벡터)

r = P1 - P3 = 두 선분의 시작점이 얼마나 떨어져 있는가

    P3 ●─ ─ ─ ─ ─ ─ → P1
          r (시작점 차이)
```

### 단계 2: 내적 계산

방향 벡터들 사이의 내적을 구합니다.

```python
# 코드 (326-328행)
a = _dot(d1, d1)  # d1·d1 = |d1|² = 선분1 길이의 제곱
e = _dot(d2, d2)  # d2·d2 = |d2|² = 선분2 길이의 제곱
f = _dot(d2, r)   # d2·r  (나중에 t를 구하는 데 사용)
```

그리고 일반적인 경우에 추가로:

```python
# 코드 (340행, 347행)
c = _dot(d1, r)   # d1·r  (나중에 s를 구하는 데 사용)
b = _dot(d1, d2)  # d1·d2 (두 선분 방향의 관계)
```

각 값의 의미를 표로 정리하면:

| 변수 | 계산 | 의미 |
|------|------|------|
| `a` | d1 . d1 | 선분1 길이의 제곱 |
| `e` | d2 . d2 | 선분2 길이의 제곱 |
| `b` | d1 . d2 | 두 선분이 얼마나 같은 방향인지 |
| `c` | d1 . r | 시작점 차이와 선분1 방향의 관계 |
| `f` | d2 . r | 시작점 차이와 선분2 방향의 관계 |

### 단계 3: 최적의 s, t 구하기 (핵심!)

우리의 목표를 다시 정리합시다:

```
선분1 위의 점: P1 + s × d1     (s는 0~1)
선분2 위의 점: P3 + t × d2     (t는 0~1)

이 두 점 사이의 거리가 최소가 되는 s와 t를 찾아라!
```

이것은 수학적으로 다음과 같이 풀립니다:

```
분모(denom) = a × e - b × b

s = (b × f - c × e) / denom
t = (b × s + f) / e
```

> **왜 이 공식인가?**: 두 점 사이의 거리 제곱을 s와 t에 대해 미분하고 0으로 놓으면
> (=최소가 되는 조건) 이 식이 나옵니다. 미분을 모르셔도 괜찮습니다.
> "이 공식이 최소 거리를 주는 s, t를 알려준다"는 것만 알면 됩니다!

```python
# 코드 (348-355행) - 일반적인 경우
b = _dot(d1, d2)
denom = a * e - b * b             # 분모

if abs(denom) > EPSILON:           # 분모가 0이 아니면 (= 평행하지 않으면)
    s = max(0.0, min(1.0,          # 0~1로 제한(클램핑)
            (b * f - c * e) / denom))
else:
    s = 0.0                        # 평행하면 s=0으로 고정

t = (b * s + f) / e                # s로부터 t 계산
```

### 단계 4: 클램핑 (0~1 범위로 제한)

공식으로 구한 s와 t는 0~1 범위를 벗어날 수 있습니다!

```
s = 1.5의 의미?
  "선분을 넘어선 가상의 지점"  → 실제로는 존재하지 않는 점!

    ●──────────────────●╌╌╌╌╌╌╌╌○
    P1       선분 구간       P2     s=1.5 (여기는 없음!)
    s=0                  s=1

t = -0.3의 의미?
  "선분 시작점보다 더 뒤쪽"  → 역시 존재하지 않는 점!

    ○╌╌╌╌╌●──────────────────●
   t=-0.3  P3       선분 구간       P4
   (없음!)  t=0                  t=1
```

그래서 벗어난 값은 가장 가까운 유효 값으로 "밀어넣습니다" (클램핑, clamping):

```
값이 0보다 작으면 → 0으로
값이 1보다 크면  → 1로

max(0.0, min(1.0, 값))  ← 이 코드가 클램핑!

예:
  s = 1.5  → max(0, min(1, 1.5)) = max(0, 1.0) = 1.0
  s = -0.3 → max(0, min(1, -0.3)) = max(0, -0.3) = 0.0
  s = 0.7  → max(0, min(1, 0.7))  = max(0, 0.7) = 0.7  (그대로)
```

**중요**: t가 클램핑되면 s도 다시 계산해야 합니다!

```python
# 코드 (357-362행)
if t < 0.0:
    t = 0.0
    s = max(0.0, min(1.0, -c / a))       # s를 다시 계산!
elif t > 1.0:
    t = 1.0
    s = max(0.0, min(1.0, (b - c) / a))  # s를 다시 계산!
```

왜 다시 계산하냐고요?

```
원래: s=1.5, t=-0.3  ← 이론적인 최적값 (선분 밖)

단순 클램핑만 하면: s=1.0, t=0.0
  → 이 조합이 정말 최적? 아닐 수 있음!

t=0.0으로 고정한 뒤 s를 다시 최적화:
  → t=0.0일 때 s가 몇이면 가장 가까운지 새로 구함
  → 이것이 진짜 정답!
```

### 단계 5: 최소 거리 점 계산

최적의 s, t를 구했으니 실제 좌표를 계산합니다.

```python
# 코드 (365-374행)
closest1 = (
    p1[0] + s * d1[0],    # 선분1 위의 가장 가까운 점
    p1[1] + s * d1[1],
    p1[2] + s * d1[2],
)
closest2 = (
    p3[0] + t * d2[0],    # 선분2 위의 가장 가까운 점
    p3[1] + t * d2[1],
    p3[2] + t * d2[2],
)
```

### 단계 6: 두 점 사이의 거리 = 최종 답

```python
# 코드 (376행)
return calculate_distance_3d(closest1, closest2)
```

```
    선분1:  ●━━━━━━━━★━━━━━━━━━●
                     │
                     │ ← 이 거리가 최소 거리!
                     │
    선분2:  ●━━━━━━━━━━━━★━━━━●

    ★ = 가장 가까운 점 (closest1, closest2)
```

---

## 7. 특수한 경우(엣지 케이스) 처리

알고리즘에서는 몇 가지 특수한 경우를 먼저 확인합니다.

### 경우 1: 두 선분이 모두 점일 때 (길이 = 0)

만약 시작점과 끝점이 같은 경우 (선분 길이가 0), 그것은 "점"입니다.

```
선분 길이가 0인 경우:
    P1 = P2 = (10, 20, 30)  → 그냥 점 하나!

    a = d1·d1 = |d1|² ≈ 0  (길이가 0이니까)
```

두 선분이 모두 점이면? 그냥 두 점 사이의 거리를 구하면 됩니다!

```python
# 코드 (331-333행)
EPSILON = 1e-8  # 0.00000001 (거의 0인지 판단하는 기준)
if a < EPSILON and e < EPSILON:
    return calculate_distance_3d(p1, p3)  # 그냥 두 점 거리!
```

```
왜 EPSILON?
  컴퓨터에서 실수 계산은 완벽하지 않습니다.
  0이 되어야 할 값이 0.0000000001 같은 아주 작은 수가 될 수 있습니다.
  그래서 "거의 0"인지를 EPSILON(매우 작은 수)과 비교합니다.

  a < 0.00000001 → "a는 사실상 0이다" → "선분 길이가 사실상 0이다"
```

### 경우 2: 한쪽 선분만 점일 때

```python
# 코드 (335-338행) - 선분1이 점인 경우
if a < EPSILON:
    s = 0.0                            # 점이니까 s는 무조건 0
    t = max(0.0, min(1.0, f / e))      # 선분2에서 가장 가까운 점만 찾으면 됨

# 코드 (341-344행) - 선분2가 점인 경우
if e < EPSILON:
    t = 0.0                            # 점이니까 t는 무조건 0
    s = max(0.0, min(1.0, -c / a))     # 선분1에서 가장 가까운 점만 찾으면 됨
```

```
그림으로:

선분1이 점인 경우:
    점 ★                           선분2에서 ★에 가장 가까운 점을 찾음

    선분2: ●━━━━━━━━━☆━━━━━━━━━●
                     ↑
                  여기가 가장 가까움!
```

### 경우 3: 두 선분이 평행할 때

두 선분이 같은 방향(또는 정반대 방향)으로 나란히 있을 때:

```
    선분1: ●────────────────●

    선분2: ●────────────────●

    (나란히 있음)
```

이 경우 `denom = a × e - b × b`가 0에 가까워집니다.

```python
# 코드 (350-353행)
if abs(denom) > EPSILON:
    s = max(0.0, min(1.0, (b * f - c * e) / denom))
else:
    s = 0.0  # 평행할 때는 s=0으로 시작하고, t를 최적화
```

왜 `denom`이 0이 되냐고요?

```
denom = a × e - b × b

a = |d1|² (선분1 길이의 제곱)
e = |d2|² (선분2 길이의 제곱)
b = d1·d2

두 선분이 완전히 같은 방향이면:
  b = |d1| × |d2|  (내적의 최대값)
  b² = |d1|² × |d2|² = a × e
  denom = a × e - a × e = 0!

→ 분모가 0이면 나눗셈 불가 → 특별 처리 필요!
```

---

## 8. 숫자로 따라가는 전체 예제

실제 두 크레인으로 알고리즘 전체를 처음부터 끝까지 따라가 봅시다.

### 크레인 설정

```
┌─────────────────────────────────────────────┐
│  크레인 A (1호기)                             │
│    기초 위치: (0, 0)                          │
│    마스트 높이: 40m                           │
│    붐대 길이: 60m                             │
│    선회각: 60° (북쪽에서 시계방향 60°)         │
│    기복각: 15° (수평에서 위로 15°)             │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│  크레인 B (2호기)                             │
│    기초 위치: (80, 0)    ← A에서 동쪽 80m     │
│    마스트 높이: 45m                           │
│    붐대 길이: 55m                             │
│    선회각: 220° (대략 남서쪽)                  │
│    기복각: 10° (거의 수평)                     │
└─────────────────────────────────────────────┘
```

```
위에서 내려다 본 대략적인 배치:

         Y (북)
         │
         │      ╱  A 붐대 (60° 방향)
         │    ╱
         │  ╱
    A기초 ●                    ● B기초
   (0,0)  │                  (80,0)
         │                    ╲
         │                      ╲  B 붐대 (220° 방향)
         │                        ╲
─────────┼─────────────────────────────── X (동)
         │
```

### STEP 1: 붐대 선분 계산

각 크레인의 붐대를 선분(시작점, 끝점)으로 바꿉니다.

#### 크레인 A의 붐대 선분

```
시작점 P1 = 마스트 꼭대기 = (기초X, 기초Y, 마스트높이)
         = (0, 0, 40)

끝  점 P2 = 붐대 끝점 계산:
  수평거리 = 60 × cos(15°) = 60 × 0.9659 = 57.96m
  tip_x   = 0 + 57.96 × sin(60°) = 57.96 × 0.8660 = 50.19m
  tip_y   = 0 + 57.96 × cos(60°) = 57.96 × 0.5000 = 28.98m
  tip_z   = 40 + 60 × sin(15°) = 40 + 60 × 0.2588 = 55.53m

  P2 = (50.19, 28.98, 55.53)
```

#### 크레인 B의 붐대 선분

```
시작점 P3 = 마스트 꼭대기 = (80, 0, 45)

끝  점 P4 = 붐대 끝점 계산:
  수평거리 = 55 × cos(10°) = 55 × 0.9848 = 54.16m
  tip_x   = 80 + 54.16 × sin(220°) = 80 + 54.16 × (-0.6428) = 80 - 34.82 = 45.18m
  tip_y   = 0  + 54.16 × cos(220°) = 0  + 54.16 × (-0.7660) = -41.49m
  tip_z   = 45 + 55 × sin(10°) = 45 + 55 × 0.1736 = 54.55m

  P4 = (45.18, -41.49, 54.55)
```

> sin(220°) = -sin(40°) = -0.6428, cos(220°) = -cos(40°) = -0.7660
> 220도는 남서쪽이므로 x, y 모두 음의 방향으로 이동합니다.

#### 정리

```
┌──────────────────────────────────────────────┐
│  선분 A: P1(0, 0, 40) ────→ P2(50.19, 28.98, 55.53)   │
│  선분 B: P3(80, 0, 45) ────→ P4(45.18, -41.49, 54.55) │
└──────────────────────────────────────────────┘
```

### STEP 2: 방향 벡터 계산

```
d1 = P2 - P1 = (50.19 - 0, 28.98 - 0, 55.53 - 40)
             = (50.19, 28.98, 15.53)

d2 = P4 - P3 = (45.18 - 80, -41.49 - 0, 54.55 - 45)
             = (-34.82, -41.49, 9.55)

r  = P1 - P3 = (0 - 80, 0 - 0, 40 - 45)
             = (-80, 0, -5)
```

### STEP 3: 내적 계산

하나씩 차근차근 계산합시다:

#### a = d1 . d1 (선분A 길이의 제곱)

```
a = 50.19 × 50.19 + 28.98 × 28.98 + 15.53 × 15.53
  = 2519.04 + 839.84 + 241.18
  = 3600.06

(확인: √3600.06 ≈ 60.00 → 붐대A 길이 60m ✓)
```

#### e = d2 . d2 (선분B 길이의 제곱)

```
e = (-34.82) × (-34.82) + (-41.49) × (-41.49) + 9.55 × 9.55
  = 1212.43 + 1721.42 + 91.20
  = 3025.05

(확인: √3025.05 ≈ 55.00 → 붐대B 길이 55m ✓)
```

#### f = d2 . r

```
f = (-34.82) × (-80) + (-41.49) × 0 + 9.55 × (-5)
  = 2785.60 + 0 + (-47.75)
  = 2737.85
```

#### c = d1 . r

```
c = 50.19 × (-80) + 28.98 × 0 + 15.53 × (-5)
  = -4015.20 + 0 + (-77.65)
  = -4092.85
```

#### b = d1 . d2

```
b = 50.19 × (-34.82) + 28.98 × (-41.49) + 15.53 × 9.55
  = -1747.61 + (-1202.38) + 148.31
  = -2801.68
```

#### 결과 요약 표

| 변수 | 값 | 의미 |
|------|------|------|
| a | 3600.06 | 선분A 길이² (≈ 60²) |
| e | 3025.05 | 선분B 길이² (≈ 55²) |
| b | -2801.68 | 두 선분 방향 관계 (음수 → 대략 반대 방향) |
| c | -4092.85 | 시작점 차이와 선분A 방향 관계 |
| f | 2737.85 | 시작점 차이와 선분B 방향 관계 |

### STEP 4: 분모(denom) 계산

```
denom = a × e - b × b
      = 3600.06 × 3025.05 - (-2801.68)²
      = 10,890,252 - 7,849,410
      = 3,040,842
```

`denom`이 0보다 훨씬 크므로 → 두 선분은 평행하지 않습니다.

### STEP 5: 최적 s 계산

```
s = (b × f - c × e) / denom

  b × f = (-2801.68) × 2737.85 = -7,668,060
  c × e = (-4092.85) × 3025.05 = -12,380,920

  분자 = b×f - c×e
       = (-7,668,060) - (-12,380,920)
       = -7,668,060 + 12,380,920
       = 4,712,860

  s = 4,712,860 / 3,040,842
    = 1.5499
```

**s = 1.5499??** 이것은 1보다 큽니다!

```
의미: "선분을 넘어선 가상의 점이 이론적 최적"

    P1 ●━━━━━━━━━━━━━━━● P2 ╌╌╌╌╌╌╌╌ ○ s=1.55
    s=0                s=1              (여기는 실제 붐대가 없음!)
```

클램핑 적용:

```
s = max(0.0, min(1.0, 1.5499))
  = max(0.0, 1.0)
  = 1.0   ← 끝점으로 제한됨!
```

### STEP 6: t 계산

```
t = (b × s + f) / e
  = ((-2801.68) × 1.0 + 2737.85) / 3025.05
  = (-2801.68 + 2737.85) / 3025.05
  = -63.83 / 3025.05
  = -0.0211
```

**t = -0.0211??** 이것은 0보다 작습니다!

```
의미: "선분 시작점보다 더 뒤쪽이 이론적 최적"

    ○ t=-0.02  P3 ●━━━━━━━━━━━━━━━● P4
   (없음!)     t=0                 t=1
```

### STEP 7: t가 범위 밖이므로 재계산

t < 0이므로 코드의 이 부분이 실행됩니다:

```python
if t < 0.0:
    t = 0.0                            # t를 0으로 고정
    s = max(0.0, min(1.0, -c / a))     # s를 다시 최적화
```

```
t = 0.0 (P3에 고정)

s = max(0.0, min(1.0, -c / a))
  = max(0.0, min(1.0, -(-4092.85) / 3600.06))
  = max(0.0, min(1.0, 4092.85 / 3600.06))
  = max(0.0, min(1.0, 1.1369))
  = max(0.0, 1.0)
  = 1.0
```

### STEP 8: 최종 결과

```
s = 1.0 → 선분A의 끝점 (P2 = 붐대A 끝점)
t = 0.0 → 선분B의 시작점 (P3 = 마스트B 꼭대기)
```

가장 가까운 두 점:

```
closest1 = P1 + 1.0 × d1
         = (0 + 1.0 × 50.19, 0 + 1.0 × 28.98, 40 + 1.0 × 15.53)
         = (50.19, 28.98, 55.53)   ← 크레인A의 붐대 끝점!

closest2 = P3 + 0.0 × d2
         = (80 + 0, 0 + 0, 45 + 0)
         = (80, 0, 45)             ← 크레인B의 마스트 꼭대기!
```

최소 거리:

```
거리 = √((50.19-80)² + (28.98-0)² + (55.53-45)²)
     = √((-29.81)² + 28.98² + 10.53²)
     = √(888.64 + 839.84 + 110.88)
     = √1839.36
     = 42.89m
```

### 결과 시각화

```
                         ★ P2 = closest1
                        ╱   A의 붐대 끝점
                       ╱    (50.19, 28.98, 55.53)
         A의 붐대     ╱
                     ╱          42.89m
                    ╱       ╱
                   ╱    ╱    (이 거리가 최소!)
    A 마스트  ●  ╱ ╱
    P1 (0,0,40) ╱
               ╱
              ★ P3 = closest2
              B의 마스트 꼭대기
              (80, 0, 45)
              │
              │  B의 붐대
              │
              ● P4 B의 붐대 끝점
              (45.18, -41.49, 54.55)
```

### 비교: 끝점 거리 vs 선분 거리

이제 **끝점 간 거리**(tip-to-tip)도 계산해서 비교합시다.

```
끝점 간 거리 = P2와 P4 사이 거리
= √((50.19-45.18)² + (28.98-(-41.49))² + (55.53-54.55)²)
= √(5.01² + 70.47² + 0.98²)
= √(25.10 + 4966.02 + 0.96)
= √4992.08
= 70.65m
```

```
┌─────────────────────────────────────────────────┐
│                                                  │
│   끝점 간 거리 (tip-to-tip):       70.65m        │
│   선분 간 최소 거리 (segment):     42.89m        │
│                                                  │
│   차이:  70.65 - 42.89 = 27.76m !!              │
│                                                  │
│   끝점만 보면 70m나 떨어져 있다고 생각하지만,     │
│   실제 붐대의 가장 가까운 부분은 43m밖에 안 됨!   │
│                                                  │
│   ★ 선분 거리가 훨씬 정확한 판단 근거!           │
│                                                  │
└─────────────────────────────────────────────────┘
```

이 예제에서는 A의 붐대 끝점이 B의 마스트 꼭대기에 가장 가까웠습니다.
끝점끼리만 비교했다면 이 위험을 감지하지 못했을 것입니다!

---

## 9. 왜 끝점 거리보다 정확한가?

### 시각적 비교

더 극적인 예를 들어봅시다. 두 붐대가 X자로 엇갈리는 경우:

```
위에서 내려다 본 모습:

끝점끼리의 거리:

    A 끝점 ●                             ● B 끝점
            ╲                           ╱
             ╲                         ╱
              ╲                       ╱
    A 끝점 ●───╲─────────────────────╱───● B 끝점
                ╲                   ╱
                 ╲       ← 2m →   ╱
                  ╲     여기가    ╱
                   ╲   가장     ╱
                    ╲ 가까움!  ╱
                     ╲       ╱
    B 마스트 ●────────╲─────╱──────● A 마스트

    끝점 간 거리 = 50m  (실제 위험을 놓침!!)
    선분 간 거리 = 2m   (위험을 정확히 감지!)
```

### 경우별 비교 표

| 상황 | 끝점 거리 | 선분 거리 | 정확한 판단 |
|------|-----------|-----------|-------------|
| 붐대가 나란히 멀리 있음 | 50m (안전) | 50m (안전) | 둘 다 맞음 |
| 붐대가 X자로 교차 | 40m (안전?) | 3m (**위험!**) | 선분만 맞음 |
| 한쪽 끝이 다른 쪽 중간에 근접 | 30m (안전?) | 5m (**경고!**) | 선분만 맞음 |
| 붐대 끝끼리 가까움 | 4m (위험) | 4m (위험) | 둘 다 맞음 |

### 핵심 포인트

```
┌─────────────────────────────────────────────────────┐
│                                                      │
│  끝점 거리 ≥ 선분 거리   (항상!)                      │
│                                                      │
│  끝점 거리 = 선분 거리인 경우:                        │
│    → 가장 가까운 점이 마침 양쪽 끝점일 때             │
│                                                      │
│  끝점 거리 > 선분 거리인 경우:                        │
│    → 붐대 중간 부분이 더 가까울 때                    │
│    → 이때 끝점만 보면 위험을 놓침!                    │
│                                                      │
│  결론: 선분 거리가 항상 끝점 거리 이하이므로,         │
│        더 보수적이고 안전한 판단을 제공합니다.         │
│                                                      │
└─────────────────────────────────────────────────────┘
```

---

## 10. 코드 위치 안내

### 핵심 함수

| 파일 | 위치 | 함수 | 역할 |
|------|------|------|------|
| `core/geometry.py` | 285-376행 | `closest_distance_between_segments()` | 두 선분 간 최소 거리 계산 |
| `core/geometry.py` | 379-381행 | `_dot()` | 내적(dot product) 계산 |
| `core/geometry.py` | 116-138행 | `calculate_distance_3d()` | 두 점 사이 3D 거리 |
| `core/geometry.py` | 249-282행 | `calculate_boom_line_segment()` | 크레인 붐대를 선분으로 변환 |

### 함수 입출력

```
  입력:  P1, P2 (선분1의 시작점, 끝점)
         P3, P4 (선분2의 시작점, 끝점)
         각각 (x, y, z) 튜플 (Point3D 타입)

  출력:  float (두 선분 사이의 최소 거리, 미터 단위)
```

### 호출 관계

```
closest_distance_between_segments(p1, p2, p3, p4)
    │
    ├── _dot(v1, v2)              내적 계산 (여러 번 호출)
    │
    └── calculate_distance_3d()    최종 거리 계산
```

### 코드 전체 구조 요약

```python
def closest_distance_between_segments(p1, p2, p3, p4):
    # ① 방향 벡터 계산              (320-323행)
    d1 = P2 - P1
    d2 = P4 - P3
    r  = P1 - P3

    # ② 내적 계산                   (326-328행)
    a = d1·d1    # 선분1 길이²
    e = d2·d2    # 선분2 길이²
    f = d2·r

    # ③ 특수 경우 처리              (331-344행)
    # - 두 선분 모두 점인 경우
    # - 한쪽만 점인 경우

    # ④ 일반 경우: s, t 계산        (346-362행)
    c = d1·r
    b = d1·d2
    denom = a*e - b*b
    s = (b*f - c*e) / denom    # 클램핑 적용
    t = (b*s + f) / e          # t 범위 벗어나면 재계산

    # ⑤ 최소 거리 점 좌표 계산      (365-374행)
    closest1 = P1 + s*d1
    closest2 = P3 + t*d2

    # ⑥ 최종 거리 반환              (376행)
    return distance(closest1, closest2)
```

---

## 11. 충돌 검사 시스템에서의 활용

이 함수는 `core/collision.py`의 `_check_pair()` 메서드에서 사용됩니다.

### 전체 검사 흐름에서의 위치

```
_check_pair(크레인A, 크레인B) 실행 흐름:

    ┌───────────────────────────────────────┐
    │ 1단계: 작업 반경 겹침 확인 (빠른 필터) │
    │                                        │
    │   반경이 안 겹침 → 즉시 "정상" 반환    │
    │   반경이 겹침   → 다음 단계로 ↓        │
    └────────────────────┬──────────────────┘
                         │
                         ▼
    ┌───────────────────────────────────────┐
    │ 2단계: 현재 거리 측정                  │
    │                                        │
    │   2-a: 붐대 끝점 간 거리 (boom_tip)    │
    │   2-b: 붐대 선분 간 최소 거리 ★ ← 여기!│
    └────────────────────┬──────────────────┘
                         │
                         ▼
    ┌───────────────────────────────────────┐
    │ 3단계: 미래 궤적 예측                  │
    └────────────────────┬──────────────────┘
                         │
                         ▼
    ┌───────────────────────────────────────┐
    │ 4단계: 위험 등급 판정                  │
    │   current_distance 기준으로 등급 결정   │
    └───────────────────────────────────────┘
```

### 실제 코드 (collision.py:270-280행)

```python
# 2-a: 붐대 끝점 간 거리
tip_a = crane_a.get_boom_tip_position()
tip_b = crane_b.get_boom_tip_position()
result.boom_tip_distance = calculate_distance_3d(tip_a, tip_b)

# 2-b: 붐대 선분 간 최소 거리 (더 정확한 측정)
seg_a = crane_a.get_boom_segment()    # (마스트꼭대기, 붐대끝) 튜플
seg_b = crane_b.get_boom_segment()    # (마스트꼭대기, 붐대끝) 튜플
result.current_distance = closest_distance_between_segments(
    seg_a[0], seg_a[1],    # 선분A: 시작점, 끝점
    seg_b[0], seg_b[1]     # 선분B: 시작점, 끝점
)
```

### 핵심: `current_distance`에 사용!

```
두 가지 거리가 계산됨:

  boom_tip_distance   = 끝점 간 거리    → 참고용
  current_distance    = 선분 간 최소 거리 → 위험 등급 판정에 사용! ★

current_distance는 항상 boom_tip_distance 이하이므로,
더 보수적(안전 지향적)인 판단을 내립니다.
```

### 위험 등급 판정 예시

```
계산 결과:
  boom_tip_distance = 70.65m  (끝점끼리)
  current_distance  = 42.89m  (선분 최소)

판정 기준 (current_distance 사용):
  ≤ 3m  → [위험]
  ≤ 5m  → [경고]
  ≤ 10m → [주의]
  > 10m → [정상]

  42.89m > 10m → [정상] 등급

만약 끝점 거리만 사용했다면?
  70.65m > 10m → 역시 [정상]
  이 경우는 결과가 같지만, X자 교차 상황이었다면
  끝점=40m(정상), 선분=3m(위험!)으로 극적으로 달라집니다!
```

### get_boom_segment()의 역할

`crane.py`에 정의된 이 메서드가 선분 데이터를 제공합니다:

```python
# crane.py:107-118
def get_boom_segment(self):
    """붐대를 선분으로 표현 (마스트 꼭대기 ~ 붐대 끝점)"""
    return calculate_boom_line_segment(
        self.base_x, self.base_y,
        self.mast_height, self.boom_length,
        self.slew_angle, self.luffing_angle,
    )
```

```
결과 예시:
  seg_a = ((0, 0, 40), (50.19, 28.98, 55.53))
           ─────────   ─────────────────────
            시작점        끝점
          (마스트 꼭대기)  (붐대 끝)
```

---

## 부록: 한눈에 보는 전체 흐름 정리

```
[크레인A]                                    [크레인B]
  기초 (0,0)                                   기초 (80,0)
  마스트 40m                                   마스트 45m
  붐대 60m                                     붐대 55m
  선회 60°, 기복 15°                           선회 220°, 기복 10°
      │                                            │
      ▼                                            ▼
  get_boom_segment()                          get_boom_segment()
      │                                            │
      ▼                                            ▼
  P1=(0,0,40)                                 P3=(80,0,45)
  P2=(50.19,28.98,55.53)                      P4=(45.18,-41.49,54.55)
      │                                            │
      └──────────────┬─────────────────────────────┘
                     │
                     ▼
    closest_distance_between_segments(P1, P2, P3, P4)
                     │
                     ├─ 방향 벡터 d1, d2, r 계산
                     ├─ 내적 a, b, c, e, f 계산
                     ├─ 최적 s=1.0, t=0.0 도출
                     ├─ closest1 = A의 붐대 끝점
                     ├─ closest2 = B의 마스트 꼭대기
                     │
                     ▼
              최소 거리 = 42.89m
                     │
                     ▼
        result.current_distance = 42.89m
                     │
                     ▼
           위험 등급 판정 → [정상]
```

---

## 더 읽어보기

| 문서 | 내용 |
|------|------|
| [05_거리계산_피타고라스.md](05_거리계산_피타고라스.md) | 점과 점 사이의 거리 계산 (이 문서의 기초) |
| [04_좌표계산_붐대위치.md](04_좌표계산_붐대위치.md) | 붐대 끝점 좌표가 어떻게 계산되는지 |
| [06_충돌예측_궤적분석.md](06_충돌예측_궤적분석.md) | 미래 위치 예측과 충돌 시간 계산 |
| [03_수학기초_삼각함수.md](03_수학기초_삼각함수.md) | sin, cos 등 삼각함수 기초 |
