# 09. 코드 해설 - 파일별 완전 가이드

> **대상 독자**: 프로그래밍 초보자
> **목적**: 크레인 충돌 예측 시스템의 모든 소스 파일을 한 줄 한 줄 설명합니다.
> **읽는 순서**: 위에서 아래로 순서대로 읽으면 시스템 전체를 이해할 수 있습니다.

---

## 목차

1. [전체 구조 한눈에 보기](#1-전체-구조-한눈에-보기)
2. [데이터 흐름도](#2-데이터-흐름도)
3. [config 모듈 - 설정 관리](#3-config-모듈---설정-관리)
4. [core 모듈 - 시스템의 두뇌](#4-core-모듈---시스템의-두뇌)
5. [simulator 모듈 - 가상 테스트](#5-simulator-모듈---가상-테스트)
6. [server 모듈 - 웹 서버](#6-server-모듈---웹-서버)
7. [static - 프론트엔드 자원](#7-static---프론트엔드-자원)
8. [templates - HTML 화면](#8-templates---html-화면)
9. [tests - 테스트 코드](#9-tests---테스트-코드)
10. [루트 파일들](#10-루트-파일들)
11. [의존성 패키지 설명](#11-의존성-패키지-설명)
12. [시스템 실행 방법](#12-시스템-실행-방법)
13. [테스트 실행 방법](#13-테스트-실행-방법)

---

## 1. 전체 구조 한눈에 보기

```
Crane-Collision-Warning/
│
├── config/                   ← [설정] 시스템 전체 설정값 모음
│   ├── __init__.py
│   └── settings.py
│
├── core/                     ← [핵심] 충돌 예측의 두뇌
│   ├── __init__.py
│   ├── geometry.py           ← 3D 수학 계산 (7개 함수)
│   ├── crane.py              ← 크레인 데이터 모델 (1개 클래스)
│   ├── collision.py          ← 충돌 판단 엔진 (2개 클래스)
│   └── alert.py              ← 경보 메시지 생성 (2개 클래스)
│
├── simulator/                ← [시뮬레이터] 가상 크레인 테스트
│   ├── __init__.py
│   ├── engine.py             ← 시뮬레이션 실행 엔진
│   └── scenarios.py          ← 5가지 사전 정의 시나리오
│
├── server/                   ← [서버] 웹 인터페이스
│   ├── __init__.py
│   ├── app.py                ← FastAPI 앱 초기화
│   ├── routes.py             ← REST API 엔드포인트
│   └── websocket.py          ← 실시간 WebSocket 통신
│
├── static/                   ← [프론트엔드] 브라우저 자원
│   ├── css/style.css         ← 화면 스타일
│   └── js/
│       ├── main.js           ← UI 제어 로직
│       ├── three-scene.js    ← 3D 시각화 (Three.js)
│       └── websocket-client.js ← 서버 통신
│
├── templates/
│   └── index.html            ← 관제 화면 HTML
│
├── tests/                    ← [테스트] 총 40개 테스트
│   ├── test_geometry.py      ← 기하학 17개
│   ├── test_collision.py     ← 충돌 엔진 9개
│   └── test_simulation.py    ← 시뮬레이션 14개
│
├── run.py                    ← 실행 스크립트
└── requirements.txt          ← 필요 패키지 목록
```

### 파일 간 의존 관계도

```
settings.py ─────────────────────────────────────────┐
     │                                                │
     ▼                                                │
geometry.py ← crane.py ← collision.py ← alert.py     │
                              │            │          │
                              ▼            ▼          │
                         engine.py ← scenarios.py     │
                              │                       │
                              ▼                       │
                    app.py ← routes.py                │
                      │    ← websocket.py ────────────┘
                      │
                      ▼
               index.html ← main.js
                           ← three-scene.js
                           ← websocket-client.js
```

**화살표(←) 의미**: "A ← B"는 "B가 A를 사용한다(import 한다)"는 뜻입니다.

---

## 2. 데이터 흐름도

시스템 전체의 데이터가 어떻게 흘러가는지 보여주는 그림입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        데이터 흐름                               │
│                                                                 │
│  ┌──────────────┐                                               │
│  │  센서 데이터   │  ← 실제 현장 (미래 구현 예정)                  │
│  └──────┬───────┘                                               │
│         │                                                       │
│         ▼                                                       │
│  ┌──────────────┐    크레인 위치/속도    ┌──────────────────┐    │
│  │  시뮬레이터    │ ──────────────────→  │  충돌 예측 엔진    │    │
│  │ (engine.py)   │    (가상 데이터)      │  (collision.py)  │    │
│  └──────────────┘                       └────────┬─────────┘    │
│                                                  │              │
│                                   충돌 검사 결과   │              │
│                                                  ▼              │
│                                         ┌──────────────────┐    │
│                                         │  경보 관리자       │    │
│                                         │  (alert.py)       │    │
│                                         └────────┬─────────┘    │
│                                                  │              │
│                                    경고 메시지     │              │
│                                                  ▼              │
│                                         ┌──────────────────┐    │
│                                         │  WebSocket 서버    │    │
│                                         │ (websocket.py)    │    │
│                                         └────────┬─────────┘    │
│                                                  │              │
│                                    JSON 데이터     │ (0.2초마다)  │
│                                                  ▼              │
│                                         ┌──────────────────┐    │
│                                         │  웹 브라우저       │    │
│                                         │  (index.html)     │    │
│                                         │  - 3D 시각화      │    │
│                                         │  - 경고 표시      │    │
│                                         │  - 제어 패널      │    │
│                                         └──────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

**핵심 흐름 요약**:

| 단계 | 무엇이 일어나는가 | 관련 파일 |
|------|-------------------|-----------|
| 1 | 크레인 위치 데이터 생성 | `simulator/engine.py` |
| 2 | 모든 크레인 쌍의 거리 계산 | `core/geometry.py` |
| 3 | 충돌 위험 여부 판단 | `core/collision.py` |
| 4 | 경고 메시지 생성 | `core/alert.py` |
| 5 | WebSocket으로 브라우저에 전송 | `server/websocket.py` |
| 6 | 3D 화면에 표시 | `static/js/three-scene.js` |

---

## 3. config 모듈 - 설정 관리

### 3-1. `config/__init__.py`

| 항목 | 내용 |
|------|------|
| **역할** | config 폴더를 Python 패키지로 인식시키는 파일 |
| **내용** | 빈 파일 (내용 없음) |
| **왜 필요?** | Python은 `__init__.py`가 있는 폴더만 패키지로 인식합니다 |

### 3-2. `config/settings.py` - 전체 설정값

| 항목 | 내용 |
|------|------|
| **역할** | 시스템 전체에서 사용하는 모든 설정값을 한 곳에 모아 관리 |
| **다른 파일과의 관계** | 거의 모든 파일이 이 파일의 값을 `import`하여 사용 |
| **핵심 패턴** | 설정값을 상수(대문자 변수)로 정의하여 코드 전반에서 재사용 |

#### 주요 설정값 목록

```python
# 1. 서버 설정
SERVER_HOST = "0.0.0.0"       # 모든 네트워크에서 접속 허용
SERVER_PORT = 8000             # http://localhost:8000

# 2. 시뮬레이션 주기
SIMULATION_INTERVAL_MS = 100   # 0.1초마다 크레인 위치 갱신
WEBSOCKET_BROADCAST_INTERVAL_MS = 200  # 0.2초마다 브라우저에 전송

# 3. 경고 기준값 (가장 중요!)
ALERT_THRESHOLDS = {
    "DANGER":  {"distance": 3.0,  "time_to_collision": 5.0},
    "WARNING": {"distance": 5.0,  "time_to_collision": 10.0},
    "CAUTION": {"distance": 10.0, "time_to_collision": 30.0},
    "NORMAL":  {"distance": 999.0, "time_to_collision": 999.0},
}

# 4. 충돌 예측 파라미터
PREDICTION_TIME_SECONDS = 30.0  # 30초 앞까지 예측
PREDICTION_STEP_SECONDS = 0.5   # 0.5초 간격으로 계산
SAFETY_MARGIN_METERS = 2.0      # 2m 이내 접근 시 충돌로 판단
```

#### 경고 등급 판단 기준표

```
거리 (미터)          등급          색상       의미
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
0m ──── 3m 이하      DANGER       빨강       즉시 정지!
3m ──── 5m 이하      WARNING      주황       속도 제한
5m ──── 10m 이하     CAUTION      노랑       운전자 알림
10m ── 그 이상       NORMAL       초록       안전
```

#### 기본 크레인 설정 (`DEFAULT_CRANES`)

```python
# 시뮬레이터에서 사용할 3대의 기본 크레인
DEFAULT_CRANES = [
    {
        "id": "TC-1",    "name": "1호기",
        "base_x": 0.0,   "base_y": 0.0,        # 원점
        "mast_height": 40.0, "boom_length": 60.0,
        "initial_slew_angle": 45.0,              # 북동쪽 방향
    },
    {
        "id": "TC-2",    "name": "2호기",
        "base_x": 80.0,  "base_y": 0.0,        # 동쪽 80m 위치
        "mast_height": 45.0, "boom_length": 55.0,
    },
    {
        "id": "TC-3",    "name": "3호기",
        "base_x": 40.0,  "base_y": 70.0,        # 북동쪽 위치
        "mast_height": 42.0, "boom_length": 50.0,
    },
]
```

#### 단위 변환 상수

```python
import math
DEG_TO_RAD = math.pi / 180.0   # 각도 → 라디안 (예: 90도 → 1.5708)
RAD_TO_DEG = 180.0 / math.pi   # 라디안 → 각도 (예: 1.5708 → 90도)
```

> **초보자 참고**: 컴퓨터의 `sin()`, `cos()` 함수는 "라디안" 단위를 사용합니다. 우리가 일상에서 쓰는 "도(degree)"와는 다른 단위이므로, 변환이 필요합니다.

---

## 4. core 모듈 - 시스템의 두뇌

이 모듈에는 충돌 예측에 필요한 핵심 로직이 모두 들어있습니다. 시스템에서 가장 중요한 부분입니다.

### 4-1. `core/__init__.py`

| 항목 | 내용 |
|------|------|
| **역할** | core 폴더를 Python 패키지로 인식시키고, 패키지 설명을 제공 |
| **내용** | 모듈 설명 docstring만 포함 |

---

### 4-2. `core/geometry.py` - 3D 기하학 계산

| 항목 | 내용 |
|------|------|
| **역할** | 크레인의 3D 좌표 계산, 거리 측정, 미래 위치 예측 등 수학적 계산 담당 |
| **다른 파일과의 관계** | `crane.py`, `collision.py`에서 함수를 가져다 사용 |
| **핵심 패턴** | 순수 함수(pure function) - 입력이 같으면 항상 같은 결과를 반환 |
| **사용하는 외부 라이브러리** | `math` (Python 기본 수학 라이브러리) |

#### 좌표계 설명

```
        Y축 (북쪽)
        ↑
        │
        │
        │
        └──────────→ X축 (동쪽)
       ╱
      ╱
     ↙ Z축 (높이/하늘 방향)
```

#### 함수 목록 (7개)

| # | 함수명 | 하는 일 | 입력 | 출력 |
|---|--------|---------|------|------|
| 1 | `calculate_boom_tip_position` | 붐대 끝점의 3D 좌표 계산 | 기초 위치, 높이, 길이, 각도들 | `(x, y, z)` 튜플 |
| 2 | `calculate_distance_3d` | 두 3D 점 사이의 거리 | 점1, 점2 | 거리(m) |
| 3 | `calculate_distance_2d` | 두 2D 점 사이의 수평 거리 | x1, y1, x2, y2 | 거리(m) |
| 4 | `check_working_radius_overlap` | 두 크레인 작업 반경 겹침 확인 | 두 크레인 위치+반경 | True/False |
| 5 | `predict_future_position` | 미래 시점 붐대 끝점 예측 | 현재 상태 + 속도 + 시간 | `(x, y, z)` 튜플 |
| 6 | `calculate_boom_line_segment` | 붐대를 선분으로 표현 | 크레인 파라미터들 | (시작점, 끝점) |
| 7 | `closest_distance_between_segments` | 두 선분 간 최소 거리 | 선분1(시작,끝), 선분2(시작,끝) | 거리(m) |
| (보조) | `_dot` | 3D 벡터 내적 계산 | 벡터1, 벡터2 | 스칼라 값 |

#### 핵심 함수 상세 해설

**함수 1: `calculate_boom_tip_position` - 붐대 끝점 계산**

이 함수는 전체 시스템에서 가장 기본이 되는 함수입니다. 크레인의 물리적 상태(위치, 높이, 각도)를 입력받아 붐대 끝점이 3D 공간의 어디에 있는지 계산합니다.

```
옆에서 본 모습:                위에서 본 모습:

       ● 붐대 끝점                  Y (북)
      ╱                             │
     ╱ 붐대 길이                     │   ● 끝점
    ╱                               │  ╱
   ╱ ← 기복각                       │╱ ← 선회각
  ● 마스트 꼭대기              ──────●──── X (동)
  │                                기초
  │ 마스트 높이
  │
──●── 지면 (기초)
```

```python
def calculate_boom_tip_position(base_x, base_y, mast_height,
                                 boom_length, slew_angle_deg, luffing_angle_deg):
    # 1단계: 각도를 라디안으로 변환
    slew_rad = math.radians(slew_angle_deg)
    luff_rad = math.radians(luffing_angle_deg)

    # 2단계: 붐대의 수평 투영 거리
    horizontal_reach = boom_length * math.cos(luff_rad)

    # 3단계: X, Y 좌표 (선회각으로 방향 결정)
    tip_x = base_x + horizontal_reach * math.sin(slew_rad)
    tip_y = base_y + horizontal_reach * math.cos(slew_rad)

    # 4단계: Z 좌표 (높이)
    tip_z = mast_height + boom_length * math.sin(luff_rad)

    return (tip_x, tip_y, tip_z)
```

> **계산 예시**: 기초(0,0), 마스트 40m, 붐대 60m, 선회각 90도(동쪽), 기복각 0도(수평)
> - `horizontal_reach = 60 * cos(0) = 60m`
> - `tip_x = 0 + 60 * sin(90도) = 0 + 60 * 1 = 60`
> - `tip_y = 0 + 60 * cos(90도) = 0 + 60 * 0 = 0`
> - `tip_z = 40 + 60 * sin(0) = 40`
> - 결과: **(60, 0, 40)** = 동쪽 60m, 높이 40m 지점

**함수 5: `predict_future_position` - 미래 위치 예측**

현재 속도가 유지된다고 가정하고, 등속 운동 공식으로 미래 각도를 계산합니다.

```python
def predict_future_position(..., current_slew_deg, slew_speed_deg_per_sec,
                            current_luffing_deg, luffing_speed_deg_per_sec,
                            time_seconds):
    # 미래 각도 = 현재 각도 + (속도 x 시간)
    future_slew = current_slew_deg + slew_speed_deg_per_sec * time_seconds
    future_luffing = current_luffing_deg + luffing_speed_deg_per_sec * time_seconds

    # 기복각은 0~80도 범위로 제한 (물리적 한계)
    future_luffing = max(0.0, min(80.0, future_luffing))

    # 선회각은 0~360도로 정규화
    future_slew = future_slew % 360.0

    return calculate_boom_tip_position(...)  # 미래 각도로 위치 계산
```

**함수 7: `closest_distance_between_segments` - 두 선분 최소 거리**

이 함수는 수학적으로 가장 복잡한 함수입니다. 두 크레인 붐대(선분)가 가장 가까운 지점의 거리를 구합니다.

```
왜 끝점 거리만으로는 부족한가?

    붐대A: ●───────────────●
                       ╲
                        ╲  ← 이 부분이 실제로 가장 가까움!
                         ╲
    붐대B:                ●───────────────●

    끝점 거리는 멀어도 중간 부분이 가까울 수 있습니다!
```

알고리즘 원리:
1. 두 선분을 매개변수 방정식으로 표현 (s: 0~1, t: 0~1)
2. 거리가 최소가 되는 s, t 값을 수학적으로 계산
3. 해당 지점 사이의 거리를 반환

---

### 4-3. `core/crane.py` - 크레인 모델

| 항목 | 내용 |
|------|------|
| **역할** | 실제 타워크레인을 소프트웨어 객체(데이터)로 표현 |
| **다른 파일과의 관계** | `geometry.py`의 함수를 사용하고, `collision.py`에서 이 클래스를 사용 |
| **핵심 패턴** | `@dataclass` - Python 데이터 클래스 패턴 |
| **사용하는 외부 라이브러리** | `math`, `time`, `dataclasses` |

#### 클래스: `TowerCrane`

```python
@dataclass
class TowerCrane:
    # 고정 속성 (설치 후 변하지 않음)
    id: str                  # "TC-1"
    name: str                # "1호기"
    base_x: float            # 기초 X좌표 (미터)
    base_y: float            # 기초 Y좌표 (미터)
    mast_height: float       # 마스트 높이 (미터)
    boom_length: float       # 붐대 길이 (미터)

    # 변동 속성 (운전 중 변함)
    slew_angle: float = 0.0  # 선회각 (도)
    luffing_angle: float = 0.0  # 기복각 (도)
    slew_speed: float = 0.0  # 선회 속도 (도/초)
    luffing_speed: float = 0.0  # 기복 속도 (도/초)

    # 상태 정보
    is_active: bool = True
    last_update: float = field(default_factory=time.time)
```

#### 메서드 목록 (7개)

| # | 메서드명 | 하는 일 | 반환값 |
|---|----------|---------|--------|
| 1 | `get_boom_tip_position()` | 현재 붐대 끝점 3D 좌표 | `(x, y, z)` |
| 2 | `get_boom_segment()` | 붐대를 선분으로 표현 | `(시작점, 끝점)` |
| 3 | `get_working_radius()` | 현재 작업 반경 계산 | 미터 |
| 4 | `get_max_working_radius()` | 최대 작업 반경 (= 붐대 길이) | 미터 |
| 5 | `update_position(dt)` | 시간 경과에 따라 자세 갱신 | 없음 |
| 6 | `to_dict()` | JSON 전송용 딕셔너리 변환 | `dict` |
| 7 | `from_config(config)` | 설정 딕셔너리로부터 객체 생성 | `TowerCrane` |

#### 핵심 메서드 상세 해설

**`update_position(dt)` - 위치 갱신**

시뮬레이터가 매 프레임(0.1초)마다 호출하여 크레인의 자세를 갱신합니다.

```python
def update_position(self, dt: float) -> None:
    if not self.is_active:
        return  # 비활성 크레인은 갱신하지 않음

    # 선회각: 현재 각도 + (속도 x 시간), 0~360도 범위 유지
    self.slew_angle = (self.slew_angle + self.slew_speed * dt) % 360.0

    # 기복각: 0~80도 범위 제한
    self.luffing_angle += self.luffing_speed * dt
    self.luffing_angle = max(0.0, min(80.0, self.luffing_angle))

    self.last_update = time.time()
```

**`to_dict()` - JSON 변환**

크레인의 모든 상태를 딕셔너리로 변환합니다. 이 데이터가 WebSocket을 통해 브라우저로 전송됩니다.

```python
def to_dict(self) -> Dict[str, Any]:
    tip = self.get_boom_tip_position()
    segment = self.get_boom_segment()
    return {
        "id": self.id,
        "name": self.name,
        "base_x": round(self.base_x, 2),
        "slew_angle": round(self.slew_angle, 2),
        "boom_tip": {"x": round(tip[0], 2), "y": round(tip[1], 2), "z": round(tip[2], 2)},
        "working_radius": round(self.get_working_radius(), 2),
        # ... (기타 속성들)
    }
```

**`from_config(config)` - 팩토리 메서드**

`settings.py`의 `DEFAULT_CRANES` 딕셔너리에서 `TowerCrane` 객체를 생성합니다.

```python
@classmethod
def from_config(cls, config: Dict[str, Any]) -> "TowerCrane":
    return cls(
        id=config["id"],
        name=config["name"],
        base_x=config["base_x"],
        # ... config.get()은 키가 없으면 기본값 사용
        slew_angle=config.get("initial_slew_angle", 0.0),
    )
```

> **초보자 참고**: `@classmethod`는 클래스 자체에서 호출하는 메서드입니다.
> `TowerCrane.from_config(config)`처럼 인스턴스 없이도 호출할 수 있습니다.

---

### 4-4. `core/collision.py` - 충돌 예측 엔진

| 항목 | 내용 |
|------|------|
| **역할** | 여러 크레인의 충돌 위험을 실시간으로 분석하는 시스템의 핵심 엔진 |
| **다른 파일과의 관계** | `crane.py`, `geometry.py`, `settings.py`에서 기능을 가져와 사용. `alert.py`와 `engine.py`에서 이 엔진을 사용 |
| **핵심 패턴** | 2단계 필터링 (빠른 사전 검사 + 정밀 검사) |
| **사용하는 외부 라이브러리** | `time`, `dataclasses` |

#### 위험 등급 상수

```python
LEVEL_NORMAL  = "NORMAL"     # 정상
LEVEL_CAUTION = "CAUTION"    # 주의
LEVEL_WARNING = "WARNING"    # 경고
LEVEL_DANGER  = "DANGER"     # 위험

LEVEL_PRIORITY = {
    LEVEL_NORMAL: 0,   # 가장 낮은 위험도
    LEVEL_CAUTION: 1,
    LEVEL_WARNING: 2,
    LEVEL_DANGER: 3,   # 가장 높은 위험도
}
```

#### 데이터클래스: `CollisionCheckResult`

두 크레인 사이의 충돌 검사 결과를 담는 그릇입니다.

```python
@dataclass
class CollisionCheckResult:
    crane_a_id: str                     # 크레인A ID
    crane_b_id: str                     # 크레인B ID
    alert_level: str = LEVEL_NORMAL     # 위험 등급
    current_distance: float = 999.0     # 붐대 간 최소 거리 (m)
    boom_tip_distance: float = 999.0    # 끝점 간 거리 (m)
    overlap_exists: bool = False        # 작업 반경 겹침 여부
    time_to_collision: Optional[float] = None  # 예상 충돌 시간 (초)
    min_predicted_distance: float = 999.0      # 예측 기간 내 최소 거리
    min_predicted_time: float = 0.0            # 최소 접근 시점
```

#### 클래스: `CollisionEngine`

| # | 메서드명 | 하는 일 |
|---|----------|---------|
| 1 | `register_crane(crane)` | 크레인을 엔진에 등록 |
| 2 | `unregister_crane(crane_id)` | 크레인을 엔진에서 해제 |
| 3 | `get_crane(crane_id)` | ID로 크레인 조회 |
| 4 | `check_all_collisions()` | **모든 크레인 쌍의 충돌 위험 검사** |
| 5 | `_check_pair(crane_a, crane_b)` | 두 크레인 상세 검사 |
| 6 | `_predict_collision(crane_a, crane_b)` | 미래 궤적 예측 |
| 7 | `_determine_alert_level(result)` | 위험 등급 판정 |
| 8 | `_check_level_change(result)` | 등급 변화 감지 및 이벤트 기록 |
| 9 | `get_overall_status()` | 전체 현장 안전 상태 요약 |

#### 충돌 검사 흐름도 (`_check_pair` 메서드)

```
입력: 크레인A, 크레인B
        │
        ▼
┌─────────────────────────────┐
│ 1단계: 작업 반경 겹침 확인   │  ← 빠른 사전 필터 (계산 비용 낮음)
│    반경 합 > 두 기초 거리?   │
└──────────┬──────────────────┘
           │
      ┌────┴────┐
      │겹침 없음 │──→ 결과: NORMAL (정상) → 종료
      └────┬────┘
      │겹침 있음 │
      └────┬────┘
           │
           ▼
┌─────────────────────────────┐
│ 2단계: 현재 거리 측정        │  ← 정밀 검사 (계산 비용 중간)
│    a) 붐대 끝점 간 거리      │
│    b) 붐대 선분 간 최소 거리 │
└──────────┬──────────────────┘
           │
           ▼
┌─────────────────────────────┐
│ 3단계: 미래 궤적 예측        │  ← 가장 무거운 계산
│    (크레인이 움직이는 경우만) │
│    0.5초 간격으로 30초 앞까지│
│    총 60개 미래 시점 계산     │
└──────────┬──────────────────┘
           │
           ▼
┌─────────────────────────────┐
│ 4단계: 위험 등급 판정        │
│    거리 기준 vs 시간 기준    │
│    더 위험한 쪽 채택         │
└──────────┬──────────────────┘
           │
           ▼
      결과 반환
```

#### 핵심 코드: 모든 크레인 쌍 검사

```python
def check_all_collisions(self) -> List[CollisionCheckResult]:
    results = []
    active_cranes = [c for c in self.cranes.values() if c.is_active]

    # 모든 크레인 쌍에 대해 검사
    # [A, B, C] → (A,B), (A,C), (B,C)
    for i in range(len(active_cranes)):
        for j in range(i + 1, len(active_cranes)):
            result = self._check_pair(active_cranes[i], active_cranes[j])
            results.append(result)
            self._check_level_change(result)  # 등급 변화 감지

    self.last_results = results
    return results
```

> **쌍의 수 계산**: 크레인이 N대이면 검사해야 할 쌍 수 = N x (N-1) / 2
> - 2대: 1쌍, 3대: 3쌍, 4대: 6쌍, 5대: 10쌍

#### 핵심 코드: 위험 등급 판정

```python
def _determine_alert_level(self, result):
    distance = result.current_distance
    ttc = result.time_to_collision  # time to collision

    # 거리 기반 판정
    if distance <= 3.0:    distance_level = "DANGER"
    elif distance <= 5.0:  distance_level = "WARNING"
    elif distance <= 10.0: distance_level = "CAUTION"
    else:                  distance_level = "NORMAL"

    # 시간 기반 판정 (예상 충돌 시간이 있는 경우)
    if ttc is not None:
        if ttc <= 5.0:     time_level = "DANGER"
        elif ttc <= 10.0:  time_level = "WARNING"
        elif ttc <= 30.0:  time_level = "CAUTION"
        else:              time_level = "NORMAL"

    # 두 기준 중 더 위험한 쪽 채택
    return max(distance_level, time_level)  # 우선순위 비교
```

---

### 4-5. `core/alert.py` - 경보 시스템

| 항목 | 내용 |
|------|------|
| **역할** | 충돌 검사 결과를 사람이 이해할 수 있는 경고 메시지로 변환 |
| **다른 파일과의 관계** | `collision.py`의 결과를 받아 처리. `engine.py`에서 호출 |
| **핵심 패턴** | 전략 패턴 - 등급별로 다른 메시지 생성 규칙 적용 |
| **사용하는 외부 라이브러리** | `time`, `dataclasses` |

#### 데이터클래스: `AlertMessage`

```python
@dataclass
class AlertMessage:
    crane_a_id: str         # 관련 크레인A
    crane_b_id: str         # 관련 크레인B
    alert_level: str        # 위험 등급
    message: str            # 화면 표시용 메시지
    voice_text: str         # 음성 안내 텍스트 (TTS용)
    color: str              # 표시 색상 (#RRGGBB)
    distance: float         # 현재 거리 (미터)
    time_to_collision: Optional[float] = None
```

#### 클래스: `AlertManager`

| # | 메서드명 | 하는 일 |
|---|----------|---------|
| 1 | `set_crane_names(names)` | 크레인 ID-이름 매핑 설정 |
| 2 | `process_results(results)` | 충돌 검사 결과 → 경고 메시지 목록 변환 |
| 3 | `_create_alert(result)` | 개별 결과 → 경고 메시지 변환 |
| 4 | `_generate_voice_text(...)` | 음성 안내 텍스트 생성 |
| 5 | `get_alerts_for_crane(crane_id, alerts)` | 특정 크레인 관련 경고만 필터링 |

#### 등급별 메시지 생성 규칙

```
등급        화면 메시지 예시                              음성 안내 예시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
CAUTION    "1호기 ↔ 2호기: 거리 8.5m (주의)"           "2호기 방향 주의. 거리 9미터."
WARNING    "1호기 ↔ 2호기: 거리 4.2m -                 "경고. 2호기 접근 중.
            15초 후 접근 예상 (경고)"                     15초 후 충돌 예상. 거리 4미터."
DANGER     "1호기 ↔ 2호기: 거리 2.1m -                 "위험! 1호기와 2호기 충돌 위험.
            즉시 정지 필요! (위험)"                       즉시 정지하세요. 거리 2미터."
```

```python
# NORMAL 등급은 경고 메시지를 생성하지 않음
def process_results(self, results):
    alerts = []
    for result in results:
        if result.alert_level != LEVEL_NORMAL:  # NORMAL 제외
            alert = self._create_alert(result)
            alerts.append(alert)
    return alerts
```

---

## 5. simulator 모듈 - 가상 테스트

### 5-1. `simulator/__init__.py`

| 항목 | 내용 |
|------|------|
| **역할** | simulator 폴더를 Python 패키지로 인식시키고, 모듈 설명 제공 |

---

### 5-2. `simulator/engine.py` - 시뮬레이션 엔진

| 항목 | 내용 |
|------|------|
| **역할** | 가상 크레인을 만들고, 움직이며, 충돌 검사를 실행하는 중앙 엔진 |
| **다른 파일과의 관계** | `crane.py`, `collision.py`, `alert.py`, `settings.py`를 모두 조합하여 사용. `app.py`에서 전역 인스턴스로 생성 |
| **핵심 패턴** | 비동기 루프 (`async/await`) + 콜백 패턴 |
| **사용하는 외부 라이브러리** | `asyncio` (Python 비동기 프로그래밍) |

#### 왜 시뮬레이터가 필요한가?

```
실제 크레인으로 테스트:                 시뮬레이터로 테스트:
- 위험함 (충돌 시 사고)               - 안전함 (가상 데이터)
- 비용이 많이 듦                      - 비용 0원
- 시간이 많이 걸림                    - 즉시 다양한 상황 재현
- 날씨에 영향받음                     - 언제든 가능
```

#### 클래스: `SimulationEngine`

```python
class SimulationEngine:
    def __init__(self):
        self.collision_engine = CollisionEngine()  # 충돌 예측 엔진
        self.alert_manager = AlertManager()        # 경보 관리자
        self.is_running = False
        self.tick_count = 0
        self.speed_multiplier = 1.0                # 배속 (2.0이면 2배속)
        self._on_update_callback = None            # 데이터 전송 콜백
```

#### 주요 메서드 목록

| # | 메서드명 | 하는 일 |
|---|----------|---------|
| 1 | `setup_default_cranes()` | `settings.py`의 기본 크레인 3대 생성 |
| 2 | `add_crane(config)` | 크레인 동적 추가 |
| 3 | `remove_crane(crane_id)` | 크레인 제거 |
| 4 | `set_crane_slew_speed(id, speed)` | 선회 속도 변경 |
| 5 | `set_crane_luffing_speed(id, speed)` | 기복 속도 변경 |
| 6 | `set_crane_slew_angle(id, angle)` | 선회각 직접 설정 |
| 7 | `set_on_update(callback)` | 데이터 갱신 콜백 등록 |
| 8 | `start()` | **시뮬레이션 비동기 루프 시작** |
| 9 | `stop()` | 시뮬레이션 정지 |
| 10 | `tick_once(dt)` | 한 번만 실행 (테스트용) |
| 11 | `get_full_state(...)` | 전체 상태를 딕셔너리로 반환 |

#### 핵심 코드: 시뮬레이션 루프

```python
async def start(self) -> None:
    self.is_running = True
    interval = SIMULATION_INTERVAL_MS / 1000.0  # 100ms → 0.1초

    while self.is_running:
        # 1. 시간 계산
        dt = (현재시간 - 이전시간) * self.speed_multiplier

        # 2. 각 크레인 위치 갱신
        for crane in self.collision_engine.cranes.values():
            crane.update_position(dt)

        # 3. 충돌 검사
        collision_results = self.collision_engine.check_all_collisions()

        # 4. 경고 메시지 생성
        alerts = self.alert_manager.process_results(collision_results)

        # 5. 콜백 호출 → WebSocket으로 브라우저에 데이터 전송
        if self._on_update_callback:
            state = self.get_full_state(collision_results, alerts)
            await self._on_update_callback(state)

        # 6. 0.1초 대기
        await asyncio.sleep(interval)
```

#### `get_full_state()` 반환 데이터 구조

```python
{
    "cranes": [           # 각 크레인의 현재 상태
        {"id": "TC-1", "name": "1호기", "slew_angle": 45.2, "boom_tip": {...}, ...},
        {"id": "TC-2", ...},
    ],
    "collisions": [       # 크레인 쌍별 충돌 검사 결과
        {"crane_a_id": "TC-1", "crane_b_id": "TC-2", "alert_level": "CAUTION", ...},
    ],
    "alerts": [           # 활성 경고 메시지 (NORMAL은 제외)
        {"message": "1호기 ↔ 2호기: 거리 8.5m (주의)", ...},
    ],
    "status": {           # 전체 현황 요약
        "total_cranes": 3,
        "highest_alert": "CAUTION",
        "crane_alerts": {"TC-1": "CAUTION", "TC-2": "CAUTION", "TC-3": "NORMAL"},
    },
    "simulation": {       # 시뮬레이션 정보
        "is_running": True,
        "tick_count": 1234,
        "speed_multiplier": 1.0,
    },
}
```

---

### 5-3. `simulator/scenarios.py` - 시나리오 정의

| 항목 | 내용 |
|------|------|
| **역할** | 미리 정의된 시나리오를 통해 다양한 상황을 즉시 재현 |
| **다른 파일과의 관계** | `engine.py`의 `SimulationEngine`을 조작. `routes.py`와 `websocket.py`에서 시나리오 API로 호출 |
| **핵심 패턴** | 데이터 딕셔너리 + 적용 함수 분리 |

#### 5가지 사전 정의 시나리오

| # | ID | 이름 | 크레인 수 | 설명 |
|---|-----|------|-----------|------|
| 1 | `normal_operation` | 정상 운행 | 3대 | 모든 크레인이 안전 거리에서 작업. 충돌 위험 없음 |
| 2 | `approaching` | 접근 상황 | 2대 | TC-1과 TC-2가 서로를 향해 회전 중. 시간에 따라 위험 상승 |
| 3 | `head_on_collision` | 정면 충돌 코스 | 2대 | 두 붐대가 서로를 정면으로 가리킴. 즉시 위험 |
| 4 | `crossing_paths` | 교차 통과 | 2대 | 두 붐대가 같은 영역을 지나가며 교차 |
| 5 | `multi_crane_congestion` | 다중 크레인 혼잡 | 4대 | 좁은 구역에 4대 배치. 복수 경고 동시 발생 |

#### 시나리오 데이터 구조

```python
SCENARIOS = {
    "approaching": {
        "name": "접근 상황",
        "description": "TC-1과 TC-2가 서로 가까이 ...",
        "cranes": [
            {
                "id": "TC-1", "name": "1호기",
                "base_x": 0.0, "base_y": 0.0,
                "mast_height": 40.0, "boom_length": 60.0,
                "initial_slew_angle": 30.0,
                "slew_speed": 0.5,    # TC-2 방향으로 회전 중
            },
            {
                "id": "TC-2", "name": "2호기",
                "base_x": 80.0, "base_y": 0.0,
                "initial_slew_angle": 210.0,
                "slew_speed": -0.5,   # TC-1 방향으로 회전 중
            },
        ],
    },
    # ... 다른 시나리오들
}
```

#### 주요 함수 (2개)

| # | 함수명 | 하는 일 |
|---|--------|---------|
| 1 | `apply_scenario(engine, scenario_name)` | 시나리오를 엔진에 적용 (기존 크레인 제거 후 새로 생성) |
| 2 | `get_scenario_list()` | 사용 가능한 시나리오 목록 반환 |

```python
def apply_scenario(engine, scenario_name):
    # 1. 기존 크레인 모두 제거
    for crane_id in list(engine.collision_engine.cranes.keys()):
        engine.remove_crane(crane_id)

    # 2. 시나리오의 크레인들 추가
    for crane_config in scenario["cranes"]:
        engine.add_crane(crane_config)

    return True
```

---

## 6. server 모듈 - 웹 서버

### 6-1. `server/__init__.py`

| 항목 | 내용 |
|------|------|
| **역할** | server 폴더를 Python 패키지로 인식시키고, 모듈 설명 제공 |

---

### 6-2. `server/app.py` - FastAPI 앱 메인

| 항목 | 내용 |
|------|------|
| **역할** | 웹 서버의 진입점. 모든 구성요소를 하나로 조합 |
| **다른 파일과의 관계** | `routes.py`, `websocket.py`의 라우터를 등록. `SimulationEngine` 전역 인스턴스 생성 |
| **핵심 패턴** | FastAPI 앱 팩토리 + 이벤트 훅(startup/shutdown) |
| **사용하는 외부 라이브러리** | `fastapi`, `uvicorn`, `jinja2` |

#### 파일 구조 해설

```python
# 1. FastAPI 앱 생성
app = FastAPI(
    title="크레인 충돌 예측 시스템",
    description="건설현장 타워크레인 간 충돌을 실시간으로 예측하고 경고하는 시스템",
    version="1.0.0",
)

# 2. 정적 파일 경로 설정 (CSS, JS 파일 제공)
app.mount("/static", StaticFiles(directory="static"), name="static")

# 3. HTML 템플릿 설정
templates = Jinja2Templates(directory="templates")

# 4. 시뮬레이션 엔진 (전역 인스턴스 - 앱 전체에서 공유)
simulation_engine = SimulationEngine()

# 5. 라우터 등록
app.include_router(api_router, prefix="/api")   # REST API: /api/...
app.include_router(ws_router)                    # WebSocket: /ws

# 6. 메인 페이지
@app.get("/")
async def main_page(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})
```

#### 서버 시작/종료 이벤트

```python
@app.on_event("startup")
async def startup_event():
    # 1. 기본 크레인 3대 생성
    simulation_engine.setup_default_cranes()

    # 2. 시뮬레이션 엔진을 백그라운드 태스크로 시작
    asyncio.create_task(simulation_engine.start())

@app.on_event("shutdown")
async def shutdown_event():
    simulation_engine.stop()
```

> **초보자 참고**: `asyncio.create_task()`는 함수를 "백그라운드"에서 실행합니다. 서버가 웹 요청을 처리하면서 동시에 시뮬레이션도 돌아갑니다.

---

### 6-3. `server/routes.py` - REST API 엔드포인트

| 항목 | 내용 |
|------|------|
| **역할** | HTTP 요청(GET/POST/DELETE)을 처리하는 API 엔드포인트 정의 |
| **다른 파일과의 관계** | `app.py`에서 라우터로 등록. `SimulationEngine`과 `scenarios.py` 사용 |
| **핵심 패턴** | FastAPI 라우터 + Pydantic 데이터 검증 |
| **사용하는 외부 라이브러리** | `fastapi`, `pydantic` |

#### Pydantic 요청 모델 (4개)

요청 데이터의 형식을 정의합니다. 형식에 맞지 않으면 자동으로 에러를 반환합니다.

```python
class CraneControlRequest(BaseModel):
    slew_speed: Optional[float] = None      # 선회 속도
    luffing_speed: Optional[float] = None   # 기복 속도
    slew_angle: Optional[float] = None      # 선회각 직접 설정
    luffing_angle: Optional[float] = None   # 기복각 직접 설정

class ScenarioApplyRequest(BaseModel):
    scenario_id: str

class SimulationSpeedRequest(BaseModel):
    speed_multiplier: float

class CraneAddRequest(BaseModel):
    id: str
    name: str
    base_x: float
    base_y: float
    # ... (기본값 있는 항목들)
```

#### API 엔드포인트 목록

| HTTP 메서드 | URL | 하는 일 | 관련 Pydantic 모델 |
|-------------|-----|---------|-------------------|
| `GET` | `/api/cranes` | 모든 크레인 상태 조회 | - |
| `GET` | `/api/cranes/{id}` | 특정 크레인 상태 조회 | - |
| `POST` | `/api/cranes/{id}/control` | 크레인 속도/각도 변경 | `CraneControlRequest` |
| `POST` | `/api/cranes` | 새 크레인 추가 | `CraneAddRequest` |
| `DELETE` | `/api/cranes/{id}` | 크레인 제거 | - |
| `GET` | `/api/status` | 전체 시스템 상태 조회 | - |
| `GET` | `/api/collisions` | 충돌 검사 결과 조회 | - |
| `GET` | `/api/scenarios` | 시나리오 목록 | - |
| `POST` | `/api/scenarios/apply` | 시나리오 적용 | `ScenarioApplyRequest` |
| `POST` | `/api/simulation/speed` | 시뮬레이션 속도 변경 | `SimulationSpeedRequest` |

#### API 사용 예시

```
# 크레인 제어 (TC-1을 시계방향 0.5도/초로 회전)
POST /api/cranes/TC-1/control
{"slew_speed": 0.5}

# 시나리오 적용
POST /api/scenarios/apply
{"scenario_id": "approaching"}

# 모든 크레인 상태 조회
GET /api/cranes
응답: {"cranes": [{"id": "TC-1", "slew_angle": 45.2, ...}, ...]}
```

#### 엔진 접근 패턴

```python
def _get_engine():
    """시뮬레이션 엔진 인스턴스를 가져오는 헬퍼 함수"""
    from server.app import get_simulation_engine  # 순환 임포트 방지
    return get_simulation_engine()
```

> **초보자 참고**: `from server.app import ...`를 함수 안에 쓴 이유는 "순환 임포트(circular import)" 문제를 피하기 위해서입니다. `app.py`가 `routes.py`를 import하고, `routes.py`가 다시 `app.py`를 import하면 무한 루프에 빠지는데, 함수 안에서 import하면 실제 호출 시점에 해결됩니다.

---

### 6-4. `server/websocket.py` - WebSocket 실시간 통신

| 항목 | 내용 |
|------|------|
| **역할** | 서버와 브라우저 사이의 실시간 양방향 통신 담당 |
| **다른 파일과의 관계** | `app.py`에서 라우터로 등록. 시뮬레이션 엔진의 콜백으로 `broadcast_state` 함수 등록 |
| **핵심 패턴** | WebSocket + 브로드캐스트(1:N 전송) + 자동 정리 |
| **사용하는 외부 라이브러리** | `fastapi`, `json` |

#### HTTP vs WebSocket 비교

```
HTTP (일반 웹):                    WebSocket (이 시스템):
━━━━━━━━━━━━━━━━━━                ━━━━━━━━━━━━━━━━━━
브라우저: "데이터 줘"              한번 연결하면 양방향
서버: "여기 있어"                  서버가 먼저 데이터를 보낼 수 있음
(연결 끊김)                       (연결 유지)
브라우저: "또 데이터 줘"           서버: "새 데이터야!" (0.2초마다)
서버: "여기 있어"                  서버: "새 데이터야!"
(연결 끊김)                       서버: "새 데이터야!"
...반복...                         브라우저: "속도 바꿔줘"
                                   서버: "확인!"
```

#### 주요 구성요소

```python
# 연결된 모든 브라우저를 추적하는 집합(Set)
connected_clients: Set[WebSocket] = set()
```

#### 함수/핸들러 목록

| # | 이름 | 하는 일 |
|---|------|---------|
| 1 | `broadcast_state(state)` | 모든 연결된 클라이언트에 상태 데이터 전송 |
| 2 | `websocket_endpoint(websocket)` | WebSocket 연결 처리 (연결/수신/종료) |
| 3 | `_handle_client_message(engine, message, websocket)` | 클라이언트 메시지 처리 |

#### 브로드캐스트 함수

```python
async def broadcast_state(state: dict) -> None:
    """모든 연결된 브라우저에 동시에 데이터 전송"""
    if not connected_clients:
        return

    message = json.dumps(state, ensure_ascii=False)  # 딕셔너리 → JSON 문자열
    disconnected = set()

    for client in connected_clients.copy():
        try:
            await client.send_text(message)
        except Exception:
            disconnected.add(client)  # 전송 실패 = 연결 끊김

    # 끊어진 연결 정리
    for client in disconnected:
        connected_clients.discard(client)
```

#### WebSocket 연결 흐름

```python
@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    # 1. 연결 수락
    await websocket.accept()
    connected_clients.add(websocket)

    # 2. 시뮬레이션 엔진에 브로드캐스트 콜백 등록
    engine = get_simulation_engine()
    engine.set_on_update(broadcast_state)

    # 3. 현재 상태 즉시 전송
    initial_state = engine.get_full_state()
    await websocket.send_text(json.dumps(initial_state))

    # 4. 메시지 수신 루프
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            await _handle_client_message(engine, message, websocket)
    except WebSocketDisconnect:
        pass
    finally:
        connected_clients.discard(websocket)  # 연결 정리
```

#### 클라이언트 메시지 타입

| 메시지 타입 | 용도 | 예시 |
|------------|------|------|
| `control` | 크레인 속도/각도 변경 | `{"type": "control", "crane_id": "TC-1", "slew_speed": 0.5}` |
| `scenario` | 시나리오 적용 | `{"type": "scenario", "scenario_id": "approaching"}` |
| `sim_speed` | 시뮬레이션 속도 변경 | `{"type": "sim_speed", "speed": 2.0}` |
| `stop_all` | 모든 크레인 정지 | `{"type": "stop_all"}` |

---

## 7. static - 프론트엔드 자원

### 7-1. `static/css/style.css` - 스타일시트

| 항목 | 내용 |
|------|------|
| **역할** | 관제 화면의 모든 시각적 디자인(색상, 배치, 크기, 애니메이션) 정의 |
| **다른 파일과의 관계** | `index.html`에서 `<link>` 태그로 로드 |
| **핵심 패턴** | CSS 변수(Custom Properties) + CSS Grid/Flexbox 레이아웃 |

#### CSS 변수 (색상 체계)

```css
:root {
    --color-normal:  #00CC00;   /* 초록 - 정상 */
    --color-caution: #FFD700;   /* 노랑 - 주의 */
    --color-warning: #FF8C00;   /* 주황 - 경고 */
    --color-danger:  #FF0000;   /* 빨강 - 위험 */
    --bg-primary:    #1a1a2e;   /* 진한 남색 배경 (관제실 느낌) */
    --bg-secondary:  #16213e;   /* 약간 밝은 배경 */
    --bg-panel:      #0f3460;   /* 패널 배경 */
    --text-primary:  #e0e0e0;   /* 밝은 회색 글자 */
}
```

#### 화면 레이아웃 구조

```
┌─ #header ──────────────────────────────────────────┐
│  시스템 이름              현재 시각  연결 상태       │
├──────────────────────────────┬─── #info-panel ─────┤
│                              │  상태 요약 패널      │
│  #view-3d-container          │  (정상/주의/경고/위험)│
│  (Three.js 3D 시각화)        ├─────────────────────┤
│                              │  크레인 제어 패널     │
│  [초기화][평면도][측면도]     │  (선회각/속도 슬라이더)│
│                              ├─────────────────────┤
│                              │  시나리오 패널        │
│                              │  [전체 정지] [속도]   │
├──── #footer ─────────────────┴─────────────────────┤
│  충돌 검사 결과 테이블 │ 경고 메시지  │ 이벤트 로그  │
└────────────────────────────────────────────────────┘
```

#### 주요 스타일 기법

```css
/* 위험 등급에 따른 행 색상 */
.row-NORMAL td  { color: var(--color-normal); }
.row-DANGER td  { color: var(--color-danger); font-weight: bold; }

/* DANGER 등급 경고는 깜박이는 애니메이션 */
.alert-DANGER {
    animation: blink 1s infinite;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* 반응형 디자인 - 작은 화면에서 레이아웃 변경 */
@media (max-width: 1200px) {
    #main-content { flex-direction: column; }
}
```

---

### 7-2. `static/js/main.js` - 메인 JavaScript

| 항목 | 내용 |
|------|------|
| **역할** | 관제 화면의 전체 동작 제어 (초기화, UI 업데이트, 사용자 입력 처리) |
| **다른 파일과의 관계** | `websocket-client.js`에서 데이터를 받아 `three-scene.js`의 3D 장면과 HTML UI를 업데이트 |
| **핵심 패턴** | 이벤트 기반 프로그래밍 (데이터 수신 → UI 갱신) |

#### 데이터 흐름

```
서버 → WebSocket → onDataReceived(state) → ┬→ updateThreeScene(state)   [3D 화면]
                                            ├→ updateStatusSummary(state) [상태 요약]
                                            ├→ updateCollisionTable(state) [충돌 테이블]
                                            ├→ updateAlertMessages(state)  [경고 메시지]
                                            ├→ updateEventLog(state)       [이벤트 이력]
                                            ├→ updateCraneSelector(state)  [크레인 선택]
                                            └→ updateSelectedCraneInfo(state) [상세 정보]
```

#### 주요 함수 분류

**초기화 함수:**

```javascript
window.addEventListener('DOMContentLoaded', function() {
    updateClock();           // 1. 시계 표시 시작
    setInterval(updateClock, 1000);  // 1초마다 갱신
    initThreeScene();        // 2. 3D 장면 초기화
    connectWebSocket();      // 3. WebSocket 연결
    loadScenarios();         // 4. 시나리오 목록 로드
});
```

**UI 업데이트 함수 (7개):**

| 함수명 | 갱신 대상 |
|--------|-----------|
| `onDataReceived(state)` | 모든 UI 한꺼번에 갱신 (다른 함수들 호출) |
| `updateStatusSummary(state)` | 상태 요약 그리드 (크레인 수, 등급별 현황) |
| `updateCollisionTable(state)` | 충돌 검사 결과 테이블 |
| `updateAlertMessages(state)` | 경고 메시지 표시 영역 |
| `updateEventLog(state)` | 이벤트 이력 (등급 변화 기록) |
| `updateCraneSelector(state)` | 크레인 선택 드롭다운 |
| `updateSelectedCraneInfo(state)` | 선택된 크레인의 상세 정보/슬라이더 |

**사용자 입력 처리 함수 (6개):**

| 함수명 | 트리거 |
|--------|--------|
| `onCraneSelected()` | 드롭다운에서 크레인 선택 |
| `onSlewAngleChange(value)` | 선회각 슬라이더 조작 |
| `onSlewSpeedChange(value)` | 선회 속도 슬라이더 조작 |
| `onLuffingAngleChange(value)` | 기복각 슬라이더 조작 |
| `stopAllCranes()` | "전체 정지" 버튼 클릭 |
| `onSimSpeedChange(value)` | 시뮬레이션 속도 슬라이더 조작 |

**유틸리티 함수 (4개):**

| 함수명 | 하는 일 |
|--------|---------|
| `updateClock()` | 현재 시각 표시 갱신 |
| `formatTimestamp(timestamp)` | 타임스탬프 → "시:분:초" 형식 변환 |
| `getLevelKorean(level)` | 등급 영문 → 한국어 변환 ("DANGER" → "위험") |
| `setTextContent(id, text)` | HTML 요소의 텍스트를 안전하게 설정 |

---

### 7-3. `static/js/three-scene.js` - 3D 시각화

| 항목 | 내용 |
|------|------|
| **역할** | Three.js 라이브러리를 사용하여 3D 공간에서 크레인을 시각적으로 표현 |
| **다른 파일과의 관계** | `main.js`에서 `initThreeScene()`과 `updateThreeScene(state)` 호출 |
| **핵심 패턴** | Scene + Camera + Renderer (Three.js 기본 패턴) |
| **사용하는 외부 라이브러리** | `Three.js` (CDN에서 로드), `OrbitControls` |

#### Three.js 기본 개념

```
3D 그래픽의 3요소:

1. Scene (장면)      ← 3D 물체들이 놓이는 공간
   ├── 크레인 A
   ├── 크레인 B
   ├── 바닥 그리드
   └── 조명

2. Camera (카메라)   ← 어디서 바라볼지
   └── 현장을 비스듬히 위에서 내려다봄

3. Renderer (렌더러) ← 카메라가 본 것을 화면에 그림
   └── 초당 60회 그림 (60fps)
```

#### 좌표계 매핑

```
우리 시스템 좌표:         Three.js 좌표:
  X = 동쪽 (오른쪽)       X = 오른쪽     (동일)
  Y = 북쪽 (앞쪽)         Y = 위쪽       (Z를 매핑)
  Z = 높이 (위쪽)         Z = 앞쪽       (Y를 매핑)

→ 우리의 Y ↔ Three.js의 Z를 교환합니다
→ 우리의 Z ↔ Three.js의 Y를 교환합니다
```

#### 크레인 3D 모델 구성

```
각 크레인 객체 구성:

    ● 붐대 끝점 (흰색 구체)
   ╱
  ╱  붐대 (boom) - 색상 있는 직육면체
 ╱
● 마스트 꼭대기
│
│  마스트 (mast) - 수직 직육면체
│
■  기초 (base) - 회색 직육면체
═══════  작업 반경 (radius) - 반투명 원
```

#### 주요 함수 목록

| # | 함수명 | 하는 일 |
|---|--------|---------|
| 1 | `initThreeScene()` | 장면, 카메라, 렌더러, 조명, 바닥 초기화 |
| 2 | `setupLighting()` | 주변광 + 방향광 + 보조광 설정 |
| 3 | `setupGround()` | 바닥 그리드(격자) + 방위 표시 |
| 4 | `createCraneObject(data, index)` | 크레인 3D 모델 생성 |
| 5 | `updateCraneObject(data, alertLevel)` | 크레인 회전/색상 갱신 |
| 6 | `updateWarningLines(collisions)` | 위험 크레인 쌍 사이에 경고선 표시 |
| 7 | `updateThreeScene(state)` | 전체 3D 장면 갱신 (메인 함수) |
| 8 | `resetCamera()` / `toggleTopView()` / `toggleSideView()` | 카메라 뷰 전환 |
| 9 | `animate()` | 60fps 렌더링 루프 |

#### 경고 시각적 표현

```python
# 위험 등급에 따른 색상 변경
if alertLevel == "DANGER":
    # 붐대 끝점 → 빨강
    # 작업 반경 → 빨강, 불투명도 높임
    # 두 크레인 사이에 빨간 점선 표시
elif alertLevel == "WARNING":
    # 붐대 끝점 → 주황
    # 경고선 주황
else:
    # 기본 색상 (흰색 끝점, 원래 색상 반경)
```

---

### 7-4. `static/js/websocket-client.js` - WebSocket 클라이언트

| 항목 | 내용 |
|------|------|
| **역할** | 서버와의 WebSocket 연결 관리 및 메시지 송수신 |
| **다른 파일과의 관계** | `main.js`에서 `connectWebSocket()` 호출. 데이터 수신 시 `main.js`의 `onDataReceived()` 호출 |
| **핵심 패턴** | 자동 재연결 + 이벤트 핸들러 패턴 |

#### 통신 흐름

```
브라우저 (이 파일)                    서버 (websocket.py)
     │                                    │
     │── 1. 연결 요청 ──────────────────→ │
     │                                    │
     │←── 2. 연결 확인 ───────────────── │  → onopen() 호출
     │                                    │
     │←── 3. 초기 상태 데이터 ────────── │  → onmessage() 호출
     │                                    │     → onDataReceived()
     │←── 4. 실시간 데이터 (0.2초마다) ── │
     │                                    │
     │── 5. 제어 명령 ──────────────────→ │  ← sendCraneControl()
     │                                    │
     │←── 6. 확인 응답 (ack) ──────────── │
     │                                    │
     │     (연결 끊김 발생)                │
     │                                    │
     │     3초 후 자동 재연결...           │  ← scheduleReconnect()
     │── 재연결 요청 ──────────────────→  │
```

#### 주요 변수

```javascript
let ws = null;                     // WebSocket 객체
let isConnected = false;           // 연결 상태
let reconnectTimer = null;         // 재연결 타이머
const RECONNECT_INTERVAL = 3000;   // 3초마다 재연결 시도
```

#### 주요 함수 목록

| # | 함수명 | 하는 일 |
|---|--------|---------|
| 1 | `connectWebSocket()` | WebSocket 서버에 연결 |
| 2 | `scheduleReconnect()` | 3초 후 재연결 예약 |
| 3 | `updateConnectionStatus(connected)` | 화면의 "연결됨/연결 끊김" 표시 갱신 |
| 4 | `sendMessage(message)` | 서버에 JSON 메시지 전송 |
| 5 | `sendCraneControl(craneId, controls)` | 크레인 제어 명령 전송 |
| 6 | `sendScenarioApply(scenarioId)` | 시나리오 적용 명령 전송 |
| 7 | `sendStopAll()` | 전체 정지 명령 전송 |
| 8 | `sendSimSpeed(speed)` | 시뮬레이션 속도 변경 명령 전송 |

#### 핵심 코드: 데이터 수신 처리

```javascript
ws.onmessage = function(event) {
    const data = JSON.parse(event.data);

    if (data.error) {
        console.warn('서버 오류:', data.error);
        return;
    }

    if (data.ack) {
        return;  // 확인 응답은 무시 (UI 갱신 불필요)
    }

    // 상태 데이터 → main.js로 전달
    onDataReceived(data);
};
```

---

## 8. templates - HTML 화면

### 8-1. `templates/index.html` - 관제 화면

| 항목 | 내용 |
|------|------|
| **역할** | 관제실 모니터에 표시되는 메인 화면의 HTML 구조 정의 |
| **다른 파일과의 관계** | `app.py`에서 Jinja2 템플릿으로 렌더링. CSS와 JS 파일을 로드 |
| **핵심 패턴** | 시맨틱 HTML5 구조 + CDN 외부 라이브러리 로드 |

#### 외부 라이브러리 로드

```html
<!-- Three.js - 3D 그래픽 라이브러리 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- OrbitControls - 마우스로 3D 뷰 회전/확대 -->
<script src="https://cdn.jsdelivr.net/.../OrbitControls.js"></script>

<!-- CSS 스타일 -->
<link rel="stylesheet" href="/static/css/style.css">
```

#### 화면 구성 영역

```html
<body>
    <!-- 1. 헤더: 시스템 이름, 시간, 연결 상태 -->
    <header id="header">...</header>

    <!-- 2. 메인 콘텐츠: 3D 뷰 + 우측 정보 패널 -->
    <main id="main-content">
        <!-- 좌측: 3D 시각화 (Three.js 캔버스) -->
        <div id="view-3d-container">
            <div id="three-canvas-wrapper"><!-- 여기에 3D 렌더링 --></div>
            <div id="view-controls">
                <button onclick="resetCamera()">초기화</button>
                <button onclick="toggleTopView()">평면도</button>
                <button onclick="toggleSideView()">측면도</button>
            </div>
        </div>

        <!-- 우측: 정보 패널 -->
        <div id="info-panel">
            <section id="status-summary"><!-- 상태 요약 --></section>
            <section id="crane-control"><!-- 크레인 제어 --></section>
            <section id="scenario-panel"><!-- 시나리오 선택 --></section>
        </div>
    </main>

    <!-- 3. 하단: 충돌 정보, 경고, 이벤트 -->
    <footer id="footer">
        <section><!-- 충돌 테이블 --></section>
        <section><!-- 경고 메시지 --></section>
        <section><!-- 이벤트 이력 --></section>
    </footer>

    <!-- JavaScript 파일 로드 (순서 중요!) -->
    <script src="/static/js/three-scene.js"></script>      <!-- 1번: 3D 기능 정의 -->
    <script src="/static/js/websocket-client.js"></script>  <!-- 2번: 통신 기능 정의 -->
    <script src="/static/js/main.js"></script>              <!-- 3번: 초기화 및 조합 -->
</body>
```

> **초보자 참고**: JavaScript 파일의 로드 순서가 중요합니다. `main.js`가 `three-scene.js`와 `websocket-client.js`의 함수를 호출하므로, 반드시 마지막에 로드해야 합니다.

#### 크레인 제어 UI 요소

```html
<!-- 선회각 슬라이더 -->
<input type="range" id="slew-angle-slider" min="0" max="360"
       oninput="onSlewAngleChange(this.value)">

<!-- 선회 속도 슬라이더 -->
<input type="range" id="slew-speed-slider" min="-2" max="2" step="0.1"
       oninput="onSlewSpeedChange(this.value)">

<!-- 전체 정지 버튼 -->
<button id="btn-stop-all" onclick="stopAllCranes()">전체 정지</button>
```

---

## 9. tests - 테스트 코드

총 **40개 테스트** (기하학 17 + 충돌 엔진 9 + 시뮬레이션 14)

### 9-1. `tests/test_geometry.py` - 기하학 테스트 (17개)

| 항목 | 내용 |
|------|------|
| **역할** | `geometry.py`의 모든 수학 함수가 올바르게 계산하는지 검증 |
| **테스트 수** | 17개 |
| **핵심 패턴** | 알려진 값으로 계산 결과를 비교 (오차 범위 0.01 이내) |

#### 테스트 클래스별 분류

| 클래스명 | 테스트 수 | 검증 대상 |
|----------|-----------|-----------|
| `TestBoomTipPosition` | 4개 | 붐대 끝점 좌표 계산 |
| `TestDistance` | 4개 | 3D/2D 거리 계산 |
| `TestWorkingRadiusOverlap` | 3개 | 작업 반경 겹침 판단 |
| `TestFuturePosition` | 3개 | 미래 위치 예측 |
| `TestSegmentDistance` | 4개 (3개 일반 + 1개 점 선분) | 선분 간 최소 거리 |

#### 대표적인 테스트 예시

```python
def test_boom_horizontal_north(self):
    """선회각 0도, 기복각 0도일 때 붐대가 정북 방향을 가리켜야 함"""
    x, y, z = calculate_boom_tip_position(
        base_x=0, base_y=0,
        mast_height=40, boom_length=60,
        slew_angle_deg=0, luffing_angle_deg=0,
    )
    assert abs(x - 0) < 0.01     # X = 0 (동서 이동 없음)
    assert abs(y - 60) < 0.01    # Y = 60 (북쪽 60m)
    assert abs(z - 40) < 0.01    # Z = 40 (마스트 높이)

def test_no_overlap(self):
    """200m 떨어진 두 크레인(반경 50m) → 겹침 없음"""
    overlap = check_working_radius_overlap(
        0, 0, 50,      # 크레인A: (0,0), 반경 50m
        200, 0, 50,    # 크레인B: (200,0), 반경 50m
    )
    assert overlap is False  # 200m > 50+50=100m
```

---

### 9-2. `tests/test_collision.py` - 충돌 엔진 테스트 (9개)

| 항목 | 내용 |
|------|------|
| **역할** | `CollisionEngine`의 충돌 판단 로직이 올바르게 동작하는지 검증 |
| **테스트 수** | 9개 |
| **핵심 패턴** | 다양한 크레인 배치 → 예상 위험 등급 검증 |

#### 테스트 목록

| # | 테스트명 | 검증 내용 |
|---|----------|-----------|
| 1 | `test_register_crane` | 크레인 등록/해제 |
| 2 | `test_no_collision_far_apart` | 멀리 떨어진 크레인 → NORMAL |
| 3 | `test_overlap_detection` | 작업 반경 겹침 감지 |
| 4 | `test_head_on_collision_danger` | 정면 대향 → DANGER |
| 5 | `test_approaching_cranes` | 접근 중인 크레인 → 예측 수행 |
| 6 | `test_multiple_cranes` | 3대 → 3쌍 결과 |
| 7 | `test_inactive_crane_excluded` | 비활성 크레인 검사 제외 |
| 8 | `test_overall_status` | 전체 상태 요약 구조 검증 |
| 9 | `test_event_log_on_level_change` | 등급 변화 시 이벤트 기록 |

#### 테스트 헬퍼 함수

```python
def make_crane(crane_id, base_x=0, base_y=0, mast_height=40,
               boom_length=60, slew_angle=0, luffing_angle=10, slew_speed=0):
    """테스트용 크레인을 간편하게 생성하는 헬퍼"""
    return TowerCrane(
        id=crane_id, name=f"테스트-{crane_id}",
        base_x=base_x, base_y=base_y,
        mast_height=mast_height, boom_length=boom_length,
        slew_angle=slew_angle, luffing_angle=luffing_angle,
        slew_speed=slew_speed,
    )
```

---

### 9-3. `tests/test_simulation.py` - 시뮬레이션 테스트 (14개)

| 항목 | 내용 |
|------|------|
| **역할** | 시뮬레이션 엔진과 시나리오 적용이 올바르게 동작하는지 검증 |
| **테스트 수** | 14개 |
| **핵심 패턴** | 시나리오 적용 → 크레인 수/상태 확인 → tick 실행 → 결과 구조 검증 |

#### 테스트 클래스별 분류

| 클래스명 | 테스트 수 | 검증 대상 |
|----------|-----------|-----------|
| `TestSimulationEngine` | 4개 | 엔진 기본 동작 (생성, 추가, 속도, tick) |
| `TestScenarios` | 10개 | 시나리오 적용 및 검증 |

#### 테스트 목록 (전체)

**SimulationEngine 테스트:**

| # | 테스트명 | 검증 내용 |
|---|----------|-----------|
| 1 | `test_setup_default_cranes` | 기본 크레인 3대 로드 |
| 2 | `test_add_and_remove_crane` | 크레인 동적 추가/제거 |
| 3 | `test_set_crane_speed` | 속도 설정 및 잘못된 ID 처리 |
| 4 | `test_tick_once` | 1초 경과 시 각도 변화 + 반환 데이터 구조 |
| 5 | `test_full_state_structure` | `get_full_state()` 반환값 구조 검증 |

**시나리오 테스트:**

| # | 테스트명 | 검증 내용 |
|---|----------|-----------|
| 6 | `test_scenario_list` | 시나리오 목록이 비어있지 않음 |
| 7 | `test_apply_normal_operation` | 정상 운행 시나리오 → 3대 |
| 8 | `test_apply_approaching` | 접근 상황 시나리오 → 2대 |
| 9 | `test_apply_head_on` | 정면 충돌 → 즉시 WARNING/DANGER |
| 10 | `test_apply_multi_crane` | 다중 크레인 → 4대, 6쌍 |
| 11 | `test_apply_invalid_scenario` | 잘못된 시나리오 → False |
| 12 | `test_scenario_replaces_cranes` | 시나리오 적용 시 기존 크레인 제거 |
| 13 | `test_all_scenarios_valid` | 모든 시나리오 데이터 무결성 검사 |
| 14 | `test_full_state_structure` | 상태 데이터 구조 완전성 |

---

## 10. 루트 파일들

### 10-1. `run.py` - 실행 스크립트

| 항목 | 내용 |
|------|------|
| **역할** | 시스템을 시작하는 가장 간단한 방법. `python run.py`로 실행 |
| **다른 파일과의 관계** | `uvicorn`을 통해 `server/app.py`의 FastAPI 앱을 실행 |
| **핵심 패턴** | `uvicorn.run()`으로 ASGI 서버 시작 |

```python
import uvicorn
from config.settings import SERVER_HOST, SERVER_PORT

def main():
    print("크레인 충돌 예측 시스템")
    print(f"접속 주소: http://localhost:{SERVER_PORT}")

    uvicorn.run(
        "server.app:app",       # server/app.py의 app 객체
        host=SERVER_HOST,       # "0.0.0.0"
        port=SERVER_PORT,       # 8000
        reload=True,            # 코드 수정 시 자동 재시작
        log_level="info",
    )

if __name__ == "__main__":
    main()
```

### 10-2. `requirements.txt` - 의존성 목록

| 항목 | 내용 |
|------|------|
| **역할** | 이 프로젝트가 필요로 하는 외부 Python 패키지 목록 |
| **사용법** | `pip install -r requirements.txt` |

---

## 11. 의존성 패키지 설명

### Python 백엔드 패키지

| 패키지 | 버전 | 역할 | 사용 위치 |
|--------|------|------|-----------|
| **fastapi** | 0.115.0 | 웹 API 프레임워크. REST API와 WebSocket을 쉽게 만들 수 있음 | `server/app.py`, `routes.py`, `websocket.py` |
| **uvicorn** | 0.30.0 | ASGI 서버. FastAPI를 실제로 실행하는 엔진 | `run.py`, `app.py` |
| **jinja2** | 3.1.4 | HTML 템플릿 엔진. `index.html`을 렌더링 | `server/app.py` |
| **python-multipart** | 0.0.9 | 파일 업로드/폼 데이터 처리 | FastAPI 내부 |
| **websockets** | 12.0 | WebSocket 프로토콜 구현 | `server/websocket.py` |
| **numpy** | 1.26.4 | 수치 계산 라이브러리 (향후 확장용) | (예비) |
| **pydantic** | 2.9.0 | 데이터 검증 및 모델 정의 | `server/routes.py` |
| **pytest** | 8.3.0 | 테스트 프레임워크 | `tests/` 전체 |
| **pytest-asyncio** | 0.24.0 | 비동기 함수 테스트 지원 | 비동기 테스트 |
| **httpx** | 0.27.0 | HTTP 클라이언트 (API 테스트용) | API 테스트 |

### 프론트엔드 라이브러리 (CDN)

| 라이브러리 | 버전 | 역할 | 로드 방식 |
|------------|------|------|-----------|
| **Three.js** | r128 | 웹 3D 그래픽 라이브러리. 크레인을 3D로 표현 | CDN `<script>` 태그 |
| **OrbitControls** | r128 | Three.js 플러그인. 마우스로 3D 뷰 회전/확대 | CDN `<script>` 태그 |

### 패키지 간 관계도

```
FastAPI (웹 프레임워크)
  ├── uvicorn (서버 엔진) ── 실행
  ├── pydantic (데이터 검증) ── 요청 데이터 형식 정의
  ├── jinja2 (템플릿) ── HTML 렌더링
  ├── websockets (WebSocket) ── 실시간 통신
  └── python-multipart (폼) ── 부가 기능

pytest (테스트)
  ├── pytest-asyncio ── 비동기 테스트
  └── httpx ── API 호출 테스트

Three.js (프론트엔드 3D)
  └── OrbitControls ── 카메라 조작
```

---

## 12. 시스템 실행 방법

### 사전 준비

```bash
# 1. 프로젝트 폴더로 이동
cd Crane-Collision-Warning

# 2. 필요한 패키지 설치
pip install -r requirements.txt
```

### 실행

```bash
# 방법 1: run.py 사용 (가장 간단)
python run.py

# 방법 2: uvicorn 직접 실행
uvicorn server.app:app --reload --host 0.0.0.0 --port 8000

# 방법 3: 모듈로 실행
python -m server.app
```

### 접속

```
웹 브라우저에서: http://localhost:8000
```

### 실행 후 동작 순서

```
1. uvicorn이 FastAPI 앱을 시작
2. startup_event() 실행
   → 기본 크레인 3대 생성
   → 시뮬레이션 엔진 백그라운드 시작
3. 브라우저에서 접속하면 index.html 반환
4. 브라우저가 WebSocket 연결
5. 시뮬레이션 엔진이 0.1초마다:
   → 크레인 위치 갱신
   → 충돌 검사
   → 경고 생성
   → WebSocket으로 브라우저에 전송
6. 브라우저가 데이터를 받아 화면 갱신
```

### 종료

```bash
# 터미널에서 Ctrl+C
```

---

## 13. 테스트 실행 방법

### 전체 테스트 실행

```bash
# 프로젝트 루트에서
python -m pytest tests/ -v
```

### 특정 파일만 실행

```bash
# 기하학 테스트만
python -m pytest tests/test_geometry.py -v

# 충돌 엔진 테스트만
python -m pytest tests/test_collision.py -v

# 시뮬레이션 테스트만
python -m pytest tests/test_simulation.py -v
```

### 특정 테스트 함수만 실행

```bash
# 특정 클래스의 특정 테스트만
python -m pytest tests/test_geometry.py::TestBoomTipPosition::test_boom_horizontal_north -v
```

### 테스트 결과 예시

```
tests/test_geometry.py::TestBoomTipPosition::test_boom_horizontal_north   PASSED
tests/test_geometry.py::TestBoomTipPosition::test_boom_horizontal_east    PASSED
tests/test_geometry.py::TestBoomTipPosition::test_boom_with_luffing       PASSED
...
tests/test_collision.py::TestCollisionEngine::test_head_on_collision_danger PASSED
...
tests/test_simulation.py::TestScenarios::test_apply_head_on              PASSED
...

========================== 40 passed ==========================
```

### 테스트 수 요약

| 테스트 파일 | 테스트 수 | 검증 대상 |
|------------|-----------|-----------|
| `test_geometry.py` | 17개 | 3D 수학 계산 정확성 |
| `test_collision.py` | 9개 | 충돌 판단 로직 |
| `test_simulation.py` | 14개 | 시뮬레이션 동작 + 시나리오 |
| **합계** | **40개** | |

---

## 부록: 자주 등장하는 코드 패턴

### 패턴 1: `@dataclass` (데이터 클래스)

```python
from dataclasses import dataclass

@dataclass
class TowerCrane:
    id: str
    name: str
    base_x: float = 0.0

# 이것만으로 아래 코드가 자동 생성됩니다:
# crane = TowerCrane(id="TC-1", name="1호기", base_x=10.0)
# print(crane)  → TowerCrane(id='TC-1', name='1호기', base_x=10.0)
```

### 패턴 2: `async/await` (비동기 프로그래밍)

```python
async def start(self):
    while self.is_running:
        # 일을 하고...
        await asyncio.sleep(0.1)  # 0.1초 기다리는 동안 다른 일도 처리 가능

# 일반 함수는 sleep(0.1) 동안 아무것도 못 하지만,
# async 함수는 await sleep(0.1) 동안 다른 요청을 처리할 수 있습니다.
```

### 패턴 3: `to_dict()` (직렬화)

```python
# Python 객체 → 딕셔너리 → JSON 문자열 → 브라우저
crane.to_dict()           # Python dict
json.dumps(crane.to_dict())  # JSON 문자열 '{"id": "TC-1", ...}'
websocket.send_text(json_str) # 브라우저로 전송
```

### 패턴 4: 콜백 함수

```python
# 1. 콜백 등록
engine.set_on_update(broadcast_state)

# 2. 나중에 엔진이 데이터를 갱신하면 자동으로 broadcast_state() 호출
if self._on_update_callback:
    await self._on_update_callback(state)
```

### 패턴 5: 2단계 필터링 (성능 최적화)

```python
# 빠른 검사 먼저 → 통과하면 비싼 검사
if not overlap_exists:
    return "NORMAL"  # 빠른 결과! 추가 계산 불필요

# 여기까지 오면 겹침이 있으므로 정밀 계산 수행
distance = closest_distance_between_segments(...)  # 무거운 계산
```

---

> **이 문서를 다 읽으셨다면**, 크레인 충돌 예측 시스템의 모든 파일이 어떤 역할을 하고, 서로 어떻게 연결되어 있는지 이해하셨을 것입니다. 코드를 직접 수정하거나 기능을 추가할 때 이 문서를 참고 자료로 활용하시기 바랍니다.
